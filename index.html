<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>HALO - Switch 2 Edition</title>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/face_mesh.js" crossorigin="anonymous"></script>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
body { background: #000; overflow: hidden; display: flex; justify-content: center; align-items: center; height: 100vh; font-family: 'Segoe UI', Arial, sans-serif; }
canvas { image-rendering: auto; }
#game { cursor: none; }
#overlay {
  position: fixed; top: 0; left: 0; width: 100%; height: 100%;
  display: flex; flex-direction: column; justify-content: center; align-items: center;
  background: linear-gradient(180deg, rgba(0,0,0,0.95) 0%, rgba(0,20,40,0.9) 50%, rgba(0,0,0,0.95) 100%);
  z-index: 10; color: #0ff; text-align: center;
}
#overlay h1 { font-size: 72px; color: #4af; font-weight: 900; letter-spacing: 16px; text-shadow: 0 0 30px #08f, 0 0 60px #048; margin-bottom: 5px; }
#overlay .subtitle { font-size: 16px; color: #68c; letter-spacing: 12px; margin-bottom: 30px; text-transform: uppercase; }
#overlay .instructions { font-size: 13px; color: #8ac; line-height: 2.2; margin-bottom: 10px; letter-spacing: 2px; }
#overlay .instructions span { color: #4df; font-weight: bold; }
#overlay .start-btn {
  font-size: 18px; color: #4af; background: rgba(0,100,200,0.1); border: 1px solid #4af;
  padding: 14px 40px; cursor: pointer; font-family: inherit; letter-spacing: 5px;
  text-transform: uppercase; transition: all 0.3s; border-radius: 3px; margin: 8px;
}
#overlay .start-btn:hover { background: rgba(0,100,200,0.3); box-shadow: 0 0 30px rgba(0,150,255,0.3); }
.start-btn.camera-btn { color: #0f8; border-color: #0f8; }
.start-btn.camera-btn:hover { background: rgba(0,200,100,0.15); box-shadow: 0 0 30px rgba(0,255,100,0.2); }
#cam-status { font-size: 12px; color: #f80; margin-top: 10px; min-height: 16px; letter-spacing: 1px; }
#cam-selector { background: rgba(0,20,40,0.8); color: #adf; border: 1px solid #4af; border-radius: 3px; padding: 6px 12px; font-family: inherit; font-size: 13px; letter-spacing: 1px; margin: 8px 0; cursor: pointer; min-width: 280px; max-width: 400px; }
#cam-selector:focus { outline: none; border-color: #0f8; box-shadow: 0 0 10px rgba(0,255,128,0.2); }
#cam-selector option { background: #0a1a2a; color: #adf; }
.cam-select-row { display: flex; align-items: center; gap: 10px; margin: 6px 0; }
.cam-select-row label { color: #68c; font-size: 12px; letter-spacing: 2px; text-transform: uppercase; white-space: nowrap; }
#how-to-play { max-width: 600px; margin: 10px auto 0; text-align: left; color: #8ac; font-size: 12px; line-height: 1.8; letter-spacing: 0.5px; display: none; max-height: 260px; overflow-y: auto; padding: 12px 16px; background: rgba(0,15,30,0.5); border: 1px solid rgba(100,170,255,0.15); border-radius: 5px; }
#how-to-play h3 { color: #4af; font-size: 14px; margin: 0 0 8px; letter-spacing: 4px; text-transform: uppercase; text-align: center; }
#how-to-play h4 { color: #4df; font-size: 12px; margin: 10px 0 4px; letter-spacing: 2px; }
#how-to-play ol, #how-to-play ul { padding-left: 20px; margin: 4px 0; }
#how-to-play li { margin: 2px 0; }
#how-to-play .tip { color: #0f8; font-weight: bold; }
#how-to-play .warn { color: #f80; }
#how-to-play::-webkit-scrollbar { width: 6px; }
#how-to-play::-webkit-scrollbar-track { background: rgba(0,10,20,0.5); }
#how-to-play::-webkit-scrollbar-thumb { background: rgba(0,120,255,0.3); border-radius: 3px; }
#toggle-help { background: none; border: 1px solid rgba(100,170,255,0.3); color: #68c; font-size: 11px; padding: 4px 14px; border-radius: 3px; cursor: pointer; font-family: inherit; letter-spacing: 2px; margin-top: 4px; transition: all 0.3s; }
#toggle-help:hover { border-color: #4af; color: #4af; }
.end-screen { position: fixed; top: 0; left: 0; width: 100%; height: 100%; display: none; flex-direction: column; justify-content: center; align-items: center; z-index: 10; text-align: center; }
#death-screen { background: radial-gradient(ellipse at center, rgba(100,0,0,0.9), rgba(20,0,0,0.95)); }
#death-screen h1 { font-size: 56px; color: #f44; text-shadow: 0 0 40px #f00; margin-bottom: 20px; font-weight: 900; letter-spacing: 8px; }
#death-screen p { color: #f99; font-size: 16px; margin-bottom: 30px; }
#win-screen { background: radial-gradient(ellipse at center, rgba(0,40,20,0.9), rgba(0,10,5,0.95)); }
#win-screen h1 { font-size: 48px; color: #4f8; text-shadow: 0 0 40px #0f4; margin-bottom: 20px; font-weight: 900; }
#win-screen p { color: #afa; font-size: 16px; margin-bottom: 10px; }
#win-stats { color: #8f8; font-size: 13px; margin-bottom: 30px; }
.end-screen .start-btn { font-size: 18px; background: rgba(255,255,255,0.05); border: 1px solid currentColor; padding: 12px 40px; cursor: pointer; font-family: inherit; letter-spacing: 4px; text-transform: uppercase; border-radius: 2px; }
#death-screen .start-btn { color: #f66; }
#win-screen .start-btn { color: #4f8; }
#cam-preview {
  position: fixed; top: 10px; right: 10px; z-index: 5;
  border: 2px solid rgba(0,255,128,0.4); border-radius: 6px;
  background: #000; display: none;
}
#gesture-label {
  position: fixed; top: 168px; right: 10px; z-index: 5;
  color: #0f8; font-size: 11px; font-family: monospace; text-align: right;
  display: none; text-shadow: 0 0 6px #000;
}
#voice-status {
  position: fixed; bottom: 10px; left: 50%; transform: translateX(-50%);
  z-index: 5; color: #4af; font-size: 11px; font-family: monospace;
  text-shadow: 0 0 6px #000; pointer-events: none;
}
#overlay-preview-wrap {
  display: none; flex-direction: column; align-items: center; margin: 10px 0 6px;
}
#overlay-cam-preview {
  border: 2px solid rgba(0,255,128,0.5); border-radius: 8px;
  background: #000; box-shadow: 0 0 20px rgba(0,255,128,0.15);
}
#overlay-gesture-label {
  color: #0f8; font-size: 12px; font-family: monospace; margin-top: 4px;
  letter-spacing: 2px; min-height: 18px; text-shadow: 0 0 8px rgba(0,255,128,0.4);
}
#btn-preview-cam {
  background: none; border: 1px solid rgba(0,255,128,0.4); color: #0f8;
  font-size: 12px; padding: 6px 18px; border-radius: 3px; cursor: pointer;
  font-family: inherit; letter-spacing: 3px; text-transform: uppercase;
  transition: all 0.3s; margin: 6px 0;
}
#btn-preview-cam:hover { background: rgba(0,255,128,0.1); box-shadow: 0 0 15px rgba(0,255,128,0.2); }
#btn-preview-cam.active { border-color: #0f8; color: #fff; background: rgba(0,255,128,0.15); }
@keyframes micPulse { 0%,100%{opacity:0.6;} 50%{opacity:1;} }
@keyframes cmdFlash { 0%{transform:scale(1);opacity:1;} 100%{transform:scale(1.02);opacity:0.85;} }
</style>
</head>
<body>

<div id="overlay">
  <h1>HALO</h1>
  <div class="subtitle">Combat Evolved &#8226; Switch 2 Edition</div>
  <div class="instructions" id="instr-camera" style="display:none">
    <span>üß† FACE</span> Tilt forward/back to move &#8226; <span>üõë STOP SIGN</span> Open palm = freeze<br>
    <span>RIGHT HAND</span> Aim &#8226; <span>PINCH</span> Fire &#8226; <span>‚úåÔ∏è PEACE</span> Door<br>
    <span>LEFT FIST</span> Sprint &#8226; <span>LEFT OPEN</span> Grenade &#8226; <span>HEAD TURN</span> Look<br>
    <span>üé§ VOICE</span> grenade / rifle / pistol / shotgun / cover me / attack
  </div>
  <div class="instructions" id="instr-keyboard">
    <span>WASD</span> Move &#8226; <span>MOUSE</span> Aim &#8226; <span>CLICK</span> Fire<br>
    <span>R</span> Reload &#8226; <span>1 2 3</span> Weapons &#8226; <span>SHIFT</span> Sprint &#8226; <span>E</span> Open Door<br>
    <span>VOICE</span> Say: rifle / pistol / shotgun / reload &#8226; attack / retreat / cover me / follow / hold
  </div>
  <div class="cam-select-row" id="cam-select-row" style="display:none">
    <label for="cam-selector">Camera:</label>
    <select id="cam-selector"><option value="">Detecting cameras...</option></select>
    <button id="btn-refresh-cams" style="background:none;border:1px solid #4af;color:#4af;border-radius:3px;padding:4px 8px;cursor:pointer;font-size:11px" title="Refresh camera list">&#x21BB;</button>
  </div>
  <button id="btn-preview-cam">&#x1F4F9; Preview Camera</button>
  <div id="overlay-preview-wrap">
    <canvas id="overlay-cam-preview" width="320" height="240"></canvas>
    <div id="overlay-gesture-label"></div>
  </div>
  <div>
    <button class="start-btn camera-btn" id="btn-camera">&#x1F4F7; Play with Camera</button>
    <button class="start-btn camera-btn" id="btn-camera-tutorial" style="font-size:14px;padding:10px 30px;border-color:#fd0;color:#fd0">üéì Camera Tutorial (Easy!)</button>
    <button class="start-btn" id="btn-keyboard">&#x2328; Play with Keyboard</button>
  </div>
  <button id="toggle-help">? HOW TO PLAY WITH CAMERA</button>
  <div id="how-to-play">
    <h3>Setup Guide</h3>
    <h4>1. Requirements</h4>
    <ul>
      <li>A <span class="tip">webcam</span> (built-in laptop cam, USB webcam, or phone-as-webcam apps all work)</li>
      <li>A modern browser (<span class="tip">Chrome, Edge, or Brave</span> recommended &mdash; Firefox may be slow)</li>
      <li>Good lighting &mdash; <span class="warn">avoid backlighting</span> (don't sit in front of a bright window)</li>
      <li>Enough room so the camera can see both your hands clearly</li>
    </ul>
    <h4>2. Selecting Your Camera</h4>
    <ol>
      <li>The <span class="tip">camera dropdown</span> above lists all detected video devices</li>
      <li>If you have multiple cameras, pick the one facing you</li>
      <li>If cameras don't appear, click <span class="tip">&#x21BB; Refresh</span> after allowing browser permission</li>
      <li>The browser will ask for camera permission &mdash; click <span class="tip">Allow</span></li>
    </ol>
    <h4>3. Hand Controls</h4>
    <ul>
      <li><span class="tip">FACE &mdash; Movement:</span> Tilt your head forward to walk, tilt back to go backwards, tilt left/right to strafe. The more you tilt, the faster you go!</li>
      <li><span class="tip">üõë STOP SIGN:</span> Hold up your open palm like a traffic cop to FREEZE in place. Works with either hand.</li>
      <li><span class="tip">LEFT FIST:</span> Make a fist with your left hand to sprint while moving.</li>
      <li><span class="tip">LEFT OPEN PALM:</span> Spread all 5 fingers on your left hand to throw a grenade! (1.5s cooldown)</li>
      <li><span class="tip">VOICE WEAPONS:</span> Say &ldquo;rifle&rdquo;, &ldquo;pistol&rdquo;, or &ldquo;shotgun&rdquo; to switch. Say &ldquo;grenade&rdquo; to throw!</li>
      <li><span class="tip">RIGHT HAND &mdash; Aiming:</span> Hold your right hand up. Move it to look/aim around.</li>
      <li><span class="tip">RIGHT PINCH:</span> Pinch your thumb and index finger together on your right hand to fire.</li>
      <li><span class="tip">RIGHT SPREAD:</span> Spread all five fingers on your right hand to reload.</li>
      <li><span class="tip">RIGHT PEACE SIGN:</span> Hold up index + middle fingers (V sign) on your right hand to open doors.</li>
    </ul>
    <h4>4. Tips for Best Tracking</h4>
    <ul>
      <li><span class="warn">Face the camera</span> with palms open toward it for best detection</li>
      <li>Keep hands <span class="tip">within the camera frame</span> &mdash; check the preview in the top-right corner</li>
      <li>Avoid <span class="warn">overlapping your hands</span> &mdash; keep them apart</li>
      <li>Wear <span class="warn">no gloves</span> &mdash; bare hands track best</li>
      <li>If tracking is jittery, try <span class="tip">slowing your movements</span></li>
      <li>Keyboard &amp; mouse <span class="tip">still work as backup</span> even in camera mode</li>
    </ul>
    <h4>5. Troubleshooting</h4>
    <ul>
      <li><span class="warn">"Camera failed"</span> &mdash; Check that no other app is using the camera. Try a different camera from the dropdown.</li>
      <li><span class="warn">Hands not detected</span> &mdash; Improve lighting, move hands closer to camera, keep palms visible.</li>
      <li><span class="warn">Laggy tracking</span> &mdash; Close other browser tabs. Use Chrome. Reduce window size.</li>
      <li><span class="warn">Wrong camera selected</span> &mdash; Pick a different option from the camera dropdown and restart.</li>
    </ul>
  </div>
  <div id="cam-status"></div>
</div>

<div id="death-screen" class="end-screen">
  <h1>KILLED IN ACTION</h1><p>The Covenant has won this battle.</p>
  <button class="start-btn" onclick="restartGame()">Try Again</button>
</div>
<div id="win-screen" class="end-screen">
  <h1>MISSION COMPLETE</h1><p>All Covenant forces neutralized.</p>
  <p id="win-stats"></p><button class="start-btn" onclick="restartGame()">Play Again</button>
</div>

<video id="camera-feed" autoplay playsinline style="display:none"></video>
<canvas id="cam-preview" width="200" height="150"></canvas>
<div id="gesture-label"></div>
<canvas id="game"></canvas>

<script>
// ============================================================================
//  HALO: SWITCH 2 EDITION ‚Äî Camera Gesture Controls + Enhanced Graphics
// ============================================================================
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');
const RENDER_W = 960, RENDER_H = 540;

function fitCanvas() {
  const s = Math.min(window.innerWidth / RENDER_W, window.innerHeight / RENDER_H);
  canvas.width = RENDER_W; canvas.height = RENDER_H;
  canvas.style.width = Math.floor(RENDER_W * s) + 'px';
  canvas.style.height = Math.floor(RENDER_H * s) + 'px';
}
fitCanvas(); window.addEventListener('resize', fitCanvas);

const screenBuffer = ctx.createImageData(RENDER_W, RENDER_H);
const buf = screenBuffer.data;
const zBuffer = new Float64Array(RENDER_W);

// ============================================================================
//  AUDIO ENGINE
// ============================================================================
let audioCtx;
function initAudio() { audioCtx = new (window.AudioContext || window.webkitAudioContext)(); }

function playSound(type) {
  if (!audioCtx) return;
  const now = audioCtx.currentTime;
  const osc = audioCtx.createOscillator();
  const gain = audioCtx.createGain();
  osc.connect(gain); gain.connect(audioCtx.destination);
  switch(type) {
    case 'shoot':
      osc.type='sawtooth'; osc.frequency.setValueAtTime(200,now); osc.frequency.exponentialRampToValueAtTime(50,now+0.1);
      gain.gain.setValueAtTime(0.25,now); gain.gain.exponentialRampToValueAtTime(0.001,now+0.1);
      osc.start(now); osc.stop(now+0.1);
      { const b=audioCtx.createBuffer(1,audioCtx.sampleRate*0.06,audioCtx.sampleRate),d=b.getChannelData(0);
        for(let i=0;i<d.length;i++) d[i]=(Math.random()*2-1)*(1-i/d.length)*0.5;
        const n=audioCtx.createBufferSource(),g2=audioCtx.createGain(); n.buffer=b;
        g2.gain.setValueAtTime(0.2,now); g2.gain.exponentialRampToValueAtTime(0.001,now+0.06);
        n.connect(g2); g2.connect(audioCtx.destination); n.start(now); n.stop(now+0.06); } break;
    case 'plasma':
      osc.type='sine'; osc.frequency.setValueAtTime(900,now); osc.frequency.exponentialRampToValueAtTime(200,now+0.2);
      gain.gain.setValueAtTime(0.15,now); gain.gain.exponentialRampToValueAtTime(0.001,now+0.2);
      osc.start(now); osc.stop(now+0.2); break;
    case 'shotgun':
      osc.type='square'; osc.frequency.setValueAtTime(80,now); osc.frequency.exponentialRampToValueAtTime(25,now+0.18);
      gain.gain.setValueAtTime(0.35,now); gain.gain.exponentialRampToValueAtTime(0.001,now+0.18);
      osc.start(now); osc.stop(now+0.18);
      { const b=audioCtx.createBuffer(1,audioCtx.sampleRate*0.15,audioCtx.sampleRate),d=b.getChannelData(0);
        for(let i=0;i<d.length;i++) d[i]=(Math.random()*2-1)*Math.pow(1-i/d.length,0.5)*0.8;
        const n=audioCtx.createBufferSource(),g2=audioCtx.createGain(); n.buffer=b;
        g2.gain.setValueAtTime(0.4,now); g2.gain.exponentialRampToValueAtTime(0.001,now+0.15);
        n.connect(g2); g2.connect(audioCtx.destination); n.start(now); n.stop(now+0.15); } break;
    case 'hit':
      osc.type='square'; osc.frequency.setValueAtTime(350,now); osc.frequency.exponentialRampToValueAtTime(100,now+0.06);
      gain.gain.setValueAtTime(0.12,now); gain.gain.exponentialRampToValueAtTime(0.001,now+0.06);
      osc.start(now); osc.stop(now+0.06); break;
    case 'enemy_die':
      osc.type='sawtooth'; osc.frequency.setValueAtTime(500,now); osc.frequency.exponentialRampToValueAtTime(60,now+0.4);
      gain.gain.setValueAtTime(0.18,now); gain.gain.exponentialRampToValueAtTime(0.001,now+0.4);
      osc.start(now); osc.stop(now+0.4); break;
    case 'pickup':
      osc.type='sine'; osc.frequency.setValueAtTime(523,now); osc.frequency.setValueAtTime(659,now+0.08);
      osc.frequency.setValueAtTime(784,now+0.16); osc.frequency.setValueAtTime(1047,now+0.24);
      gain.gain.setValueAtTime(0.15,now); gain.gain.exponentialRampToValueAtTime(0.001,now+0.35);
      osc.start(now); osc.stop(now+0.35); break;
    case 'shield_low':
      osc.type='sine'; osc.frequency.setValueAtTime(1400,now); osc.frequency.setValueAtTime(900,now+0.1);
      gain.gain.setValueAtTime(0.08,now); gain.gain.exponentialRampToValueAtTime(0.001,now+0.25);
      osc.start(now); osc.stop(now+0.25); break;
    case 'reload':
      osc.type='triangle'; osc.frequency.setValueAtTime(250,now); osc.frequency.setValueAtTime(500,now+0.12);
      gain.gain.setValueAtTime(0.12,now); gain.gain.exponentialRampToValueAtTime(0.001,now+0.2);
      osc.start(now); osc.stop(now+0.2); break;
    case 'no_ammo':
      osc.type='triangle'; osc.frequency.setValueAtTime(700,now); osc.frequency.setValueAtTime(400,now+0.06);
      gain.gain.setValueAtTime(0.08,now); gain.gain.exponentialRampToValueAtTime(0.001,now+0.08);
      osc.start(now); osc.stop(now+0.08); break;
    case 'enemy_shoot':
      osc.type='sine'; osc.frequency.setValueAtTime(650,now); osc.frequency.exponentialRampToValueAtTime(280,now+0.1);
      gain.gain.setValueAtTime(0.06,now); gain.gain.exponentialRampToValueAtTime(0.001,now+0.1);
      osc.start(now); osc.stop(now+0.1); break;
    case 'shield_regen':
      osc.type='sine'; osc.frequency.setValueAtTime(800,now); osc.frequency.setValueAtTime(1200,now+0.15);
      gain.gain.setValueAtTime(0.04,now); gain.gain.exponentialRampToValueAtTime(0.001,now+0.2);
      osc.start(now); osc.stop(now+0.2); break;
    case 'door_open':
      osc.type='triangle'; osc.frequency.setValueAtTime(100,now); osc.frequency.exponentialRampToValueAtTime(400,now+0.3);
      gain.gain.setValueAtTime(0.15,now); gain.gain.exponentialRampToValueAtTime(0.001,now+0.35);
      osc.start(now); osc.stop(now+0.35);
      { const b=audioCtx.createBuffer(1,audioCtx.sampleRate*0.3,audioCtx.sampleRate),d=b.getChannelData(0);
        for(let i=0;i<d.length;i++) d[i]=(Math.random()*2-1)*(1-i/d.length)*0.12;
        const n=audioCtx.createBufferSource(),g2=audioCtx.createGain(); n.buffer=b;
        g2.gain.setValueAtTime(0.1,now); g2.gain.exponentialRampToValueAtTime(0.001,now+0.3);
        n.connect(g2); g2.connect(audioCtx.destination); n.start(now); n.stop(now+0.3); } break;
    case 'grenade_throw':
      osc.type='sawtooth'; osc.frequency.setValueAtTime(120,now); osc.frequency.exponentialRampToValueAtTime(60,now+0.15);
      gain.gain.setValueAtTime(0.2,now); gain.gain.exponentialRampToValueAtTime(0.001,now+0.15);
      osc.start(now); osc.stop(now+0.15); break;
    case 'explosion':
      osc.type='square'; osc.frequency.setValueAtTime(60,now); osc.frequency.exponentialRampToValueAtTime(20,now+0.5);
      gain.gain.setValueAtTime(0.4,now); gain.gain.exponentialRampToValueAtTime(0.001,now+0.5);
      osc.start(now); osc.stop(now+0.5);
      { const b=audioCtx.createBuffer(1,audioCtx.sampleRate*0.5,audioCtx.sampleRate),d=b.getChannelData(0);
        for(let i=0;i<d.length;i++) d[i]=(Math.random()*2-1)*Math.pow(1-i/d.length,0.3)*0.9;
        const n=audioCtx.createBufferSource(),g2=audioCtx.createGain(); n.buffer=b;
        g2.gain.setValueAtTime(0.5,now); g2.gain.exponentialRampToValueAtTime(0.001,now+0.5);
        n.connect(g2); g2.connect(audioCtx.destination); n.start(now); n.stop(now+0.5); } break;
  }
}

// ============================================================================
//  MAP & DOOR SYSTEM
// ============================================================================
const MAP_W = 32, MAP_H = 32;
const mapData = [
  1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
  1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,
  1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,
  1,0,0,0,0,0,0,0,3,0,0,0,0,0,0,1,1,0,0,2,2,2,0,0,0,0,2,2,2,0,0,1,
  1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,1,1,0,0,2,0,0,0,0,0,0,0,0,2,0,0,1,
  1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,2,0,0,1,
  1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,
  1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,
  1,1,1,3,1,1,1,1,1,1,1,3,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,
  1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,2,0,0,0,0,0,0,0,0,2,0,0,1,
  1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3,0,0,0,2,0,0,0,0,0,0,0,0,2,0,0,1,
  1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,2,2,2,0,0,0,0,2,2,2,0,0,1,
  1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,
  1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,
  1,1,1,1,1,0,0,1,1,1,1,1,0,0,1,1,1,1,1,1,1,0,0,1,1,1,1,1,0,0,1,1,
  1,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,1,
  1,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,1,
  1,0,0,3,0,0,0,0,0,0,3,0,0,0,0,0,0,0,0,3,0,0,0,0,0,0,3,0,0,0,0,1,
  1,0,0,1,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,1,0,0,0,0,1,
  1,0,0,1,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,1,0,0,0,0,1,
  1,0,0,1,0,0,0,0,0,0,1,1,1,3,1,1,1,1,1,1,0,0,0,0,0,0,1,0,0,0,0,1,
  1,0,0,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3,0,0,0,0,1,
  1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,1,
  1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,1,
  1,0,0,1,0,0,0,0,0,0,1,1,1,3,1,1,1,1,1,1,0,0,0,0,0,0,1,0,0,0,0,1,
  1,0,0,1,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,1,0,0,0,0,1,
  1,0,0,3,0,0,0,0,0,0,3,0,0,0,0,0,0,0,0,3,0,0,0,0,0,0,3,0,0,0,0,1,
  1,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,1,0,0,0,0,1,
  1,0,0,0,0,0,0,0,0,0,1,0,0,0,2,2,0,0,0,1,0,0,0,0,0,0,1,0,0,0,0,1,
  1,0,0,0,0,0,0,0,0,0,1,0,0,2,0,0,2,0,0,1,0,0,0,0,0,0,1,0,0,0,0,1,
  1,0,0,0,0,0,0,0,0,0,1,0,0,2,0,6,2,0,0,1,0,0,0,0,0,0,0,0,0,0,0,1,
  1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
];
const mainMapData = [...mapData]; // backup of original main level

// Door system
const doors = new Map();
function doorKey(x,y) { return x+','+y; }

function initDoors() {
  doors.clear();
  for (let y=0; y<MAP_H; y++) for (let x=0; x<MAP_W; x++) {
    if (mapData[y*MAP_W+x] === 3) doors.set(doorKey(x,y), {x,y, state:'closed', openAmount:0, timer:0});
  }
}

function updateDoors(dt) {
  for (const d of doors.values()) {
    if (d.state === 'opening') {
      d.openAmount = Math.min(1, d.openAmount + dt / 0.6);
      if (d.openAmount >= 1) { d.state = 'open'; d.timer = 4.0; }
    } else if (d.state === 'open') {
      d.timer -= dt;
      const pdx = (d.x+0.5)-player.x, pdy = (d.y+0.5)-player.y;
      if (d.timer <= 0 && pdx*pdx+pdy*pdy > 2.25) d.state = 'closing';
    } else if (d.state === 'closing') {
      const pdx = (d.x+0.5)-player.x, pdy = (d.y+0.5)-player.y;
      if (pdx*pdx+pdy*pdy < 2.25) { d.state = 'open'; d.timer = 1.0; return; }
      d.openAmount = Math.max(0, d.openAmount - dt / 0.6);
      if (d.openAmount <= 0) d.state = 'closed';
    }
  }
}

function tryOpenDoor() {
  let best = null, bestD = 2.5*2.5;
  for (const d of doors.values()) {
    if (d.state !== 'closed') continue;
    const dx = (d.x+0.5)-player.x, dy = (d.y+0.5)-player.y, dist2 = dx*dx+dy*dy;
    if (dist2 < bestD) { bestD = dist2; best = d; }
  }
  if (best) { best.state = 'opening'; playSound('door_open'); }
}

function autoOpenDoors() {
  for (const d of doors.values()) {
    if (d.state !== 'closed') continue;
    const dx = (d.x+0.5)-player.x, dy = (d.y+0.5)-player.y;
    if (dx*dx+dy*dy < 1.5) { d.state = 'opening'; playSound('door_open'); }
  }
}

function getMap(x, y) {
  if (x < 0 || x >= MAP_W || y < 0 || y >= MAP_H) return 1;
  const t = mapData[y * MAP_W + x];
  if (t === 3) {
    const d = doors.get(doorKey(x,y));
    if (d && d.openAmount > 0.7) return 0;
  }
  return t;
}
function getRawMap(x,y) { if(x<0||x>=MAP_W||y<0||y>=MAP_H) return 1; return mapData[y*MAP_W+x]; }

const floorTypeMap = new Uint8Array(MAP_W * MAP_H);
for (let y=0;y<MAP_H;y++) for (let x=0;x<MAP_W;x++) {
  if ((x>=19&&x<=29&&y>=3&&y<=12)||(x>=12&&x<=16&&y>=28&&y<=30)) floorTypeMap[y*MAP_W+x]=2;
  else if (y===14||y===8||x===14||x===5||x===6) floorTypeMap[y*MAP_W+x]=1;
}

// ============================================================================
//  TEXTURES ‚Äî 128x128 procedural
// ============================================================================
const TEX_SIZE = 128;
const textures = {};

function genTexture(name, fn) {
  const data = new Uint8Array(TEX_SIZE*TEX_SIZE*4);
  for (let y=0;y<TEX_SIZE;y++) for (let x=0;x<TEX_SIZE;x++) {
    const [r,g,b] = fn(x,y);
    const i=(y*TEX_SIZE+x)*4;
    data[i]=Math.max(0,Math.min(255,r|0)); data[i+1]=Math.max(0,Math.min(255,g|0));
    data[i+2]=Math.max(0,Math.min(255,b|0)); data[i+3]=255;
  }
  textures[name] = data;
}

function hash(x,y){let n=x*374761393+y*668265263;n=(n^(n>>13))*1274126177;return(n^(n>>16))&0xff;}
function smoothNoise(x,y){
  const ix=Math.floor(x),iy=Math.floor(y),fx=x-ix,fy=y-iy;
  const sfx=fx*fx*(3-2*fx),sfy=fy*fy*(3-2*fy);
  const a=hash(ix,iy),b=hash(ix+1,iy),c=hash(ix,iy+1),d=hash(ix+1,iy+1);
  return(a+(b-a)*sfx+(c-a)*sfy+(a-b-c+d)*sfx*sfy)/255;
}
function fbm(x,y,oct){let v=0,a=1,f=1;for(let i=0;i<oct;i++){v+=smoothNoise(x*f,y*f)*a;a*=0.5;f*=2;}return v;}

genTexture('metal',(x,y)=>{const n=fbm(x*0.08,y*0.08,4);let v=90+n*40;const px=x%64,py=y%64;if(px<2||py<2)v=50+n*20;if(px===2||py===2)v=120;for(const[rx,ry] of[[8,8],[56,8],[8,56],[56,56]]){const d=Math.sqrt((px-rx)**2+(py-ry)**2);if(d<4)v=140+(4-d)*15;if(d<2)v=160;}v+=Math.sin(x*0.8)*5;return[v,v+2,v+8];});
genTexture('covenant',(x,y)=>{const n=fbm(x*0.06,y*0.06,5);let r=70+n*30,g=15+n*15,b=120+n*50;const n2=fbm(x*0.15+100,y*0.12+100,3);r+=n2*20;b+=n2*30;const v1=Math.sin(x*0.12+y*0.04+n*3);if(Math.abs(v1)<0.08){r+=80;g+=30;b+=100;}if(y%32>14&&y%32<18){r+=50;g+=20;b+=70;}if(x<3||x>124){r=40;g=5;b=70;}return[r,g,b];});
genTexture('tech',(x,y)=>{let r=20,g=35,b=25;if(x>10&&x<118&&y>10&&y<118){const scan=(y%4<2)?0.85:1.0;g=(80+Math.sin(y*0.25)*15+fbm(x*0.1,y*0.05,3)*40)*scan;b=(50+fbm(x*0.08,y*0.08,2)*25)*scan;r=(15+fbm(x*0.05,y*0.1,2)*10)*scan;if(y>20&&y<100&&x>16&&x<112){const ly=(y-20)%10;if(ly<6){const ci=Math.floor(x/5),li=Math.floor((y-20)/10);if(hash(ci,li+200)<180)g+=50;}}}if(x<=10||x>=118||y<=10||y>=118){const bv=Math.min(x,y,127-x,127-y);r=55+bv*2;g=55+bv*2;b=55+bv*2;if(bv<2){r=30;g=30;b=30;}}return[r,g,b];});
genTexture('door',(x,y)=>{let r=70,g=80,b=85;const n=fbm(x*0.05,y*0.05,3);const isL=x<62,isR=x>65;if(isL||isR){r=80+n*20;g=90+n*20;b=100+n*20;}if(x>=62&&x<=65){r=20;g=20;b=25;}if((y<12||y>116)&&((x+y)%16<8)){r=200;g=180;b=0;}if((y<12||y>116)&&((x+y)%16>=8)){r=30;g=30;b=30;}if(x>55&&x<60&&y>56&&y<72){r=50;g=200;b=50;}return[r,g,b];});
genTexture('exit',(x,y)=>{const cx=64,cy=64,d=Math.sqrt((x-cx)**2+(y-cy)**2),nd=d/64,glow=Math.max(0,1-nd);const ring=Math.abs(Math.sin(d*0.15))*glow;const n=fbm(x*0.08+50,y*0.08+50,3);let r=10+glow*80+ring*40+n*20,g=30+glow*200+ring*60+n*30,b=50+glow*255+ring*80+n*40;return[Math.min(255,r),Math.min(255,g),Math.min(255,b)];});
genTexture('floor_metal',(x,y)=>{const n=fbm(x*0.06,y*0.06,4);let v=45+n*25;const dx=((x+y)%16),dy=((x-y+128)%16);if(dx<4&&dy<4)v+=20;if(x%64<2||y%64<2)v=30;return[v,v+3,v+8];});
genTexture('floor_grate',(x,y)=>{let v=50;const gx=x%16,gy=y%16;if(gx>2&&gx<14&&gy>2&&gy<14)v=15+fbm(x*0.1,y*0.1,2)*10;else v=70+fbm(x*0.08,y*0.08,3)*20;return[v,v+2,v+5];});
genTexture('floor_covenant',(x,y)=>{const n=fbm(x*0.05,y*0.05,4);let r=40+n*20,g=10+n*10,b=60+n*30;const d=Math.sqrt((x%18-9)**2+(y%18-9)**2);if(d>7&&d<9){r+=30;g+=10;b+=40;}if(d<3){r+=20;g+=30;b+=30;}return[r,g,b];});
genTexture('ceiling',(x,y)=>{const n=fbm(x*0.05,y*0.05,3);let v=35+n*15;if(x%64<4||y%64<4)v=55+n*10;if(x>40&&x<88&&y>40&&y<88){const ld=Math.max(Math.abs(x-64),Math.abs(y-64));if(ld<20)v=200-ld*4;else if(ld<24)v=80;}return[v,v,v+10];});

const wallTexMap={1:'metal',2:'covenant',3:'door',4:'door',5:'metal',6:'exit'};
const floorTexNames=['floor_metal','floor_grate','floor_covenant'];

// ============================================================================
//  DYNAMIC LIGHTING
// ============================================================================
const lights = [
  {x:2.5,y:2.5,r:0.3,g:0.5,b:0.8,intensity:1.4,radius:7.2},
  {x:10,y:4,r:0.8,g:0.8,b:1.0,intensity:1.2,radius:6},{x:6,y:10,r:0.8,g:0.8,b:1.0,intensity:1.2,radius:6},
  {x:24,y:6,r:0.5,g:0.2,b:0.8,intensity:1.4,radius:7.2},{x:24,y:10,r:0.5,g:0.2,b:0.8,intensity:1.2,radius:6},
  {x:14,y:14,r:1.0,g:0.9,b:0.7,intensity:1.8,radius:8.4},{x:6,y:18,r:0.8,g:0.8,b:1.0,intensity:1.0,radius:6},
  {x:14,y:22,r:0.8,g:0.8,b:1.0,intensity:1.2,radius:7.2},{x:24,y:22,r:0.8,g:0.8,b:1.0,intensity:1.0,radius:6},
  {x:6,y:27,r:0.8,g:0.8,b:1.0,intensity:1.2,radius:6},{x:14,y:28,r:0.5,g:0.2,b:0.8,intensity:1.4,radius:7.2},
  {x:15,y:30,r:0.2,g:0.8,b:1.0,intensity:2.4,radius:9.6},{x:28,y:28,r:0.8,g:0.3,b:0.3,intensity:1.2,radius:6},
];

function getLightAt(wx,wy) {
  let lr=0.15,lg=0.14,lb=0.18;
  for (const l of lights) {
    const dx=wx-l.x,dy=wy-l.y,d2=dx*dx+dy*dy,r2=l.radius*l.radius;
    if(d2<r2){const att=(1-d2/r2)*l.intensity;lr+=l.r*att;lg+=l.g*att;lb+=l.b*att;}
  }
  const pdx=wx-player.x,pdy=wy-player.y,pd=Math.sqrt(pdx*pdx+pdy*pdy);
  if(pd<8){let diff=Math.atan2(pdy,pdx)-player.angle;while(diff>Math.PI)diff-=2*Math.PI;while(diff<-Math.PI)diff+=2*Math.PI;
    if(Math.abs(diff)<0.5){const spot=(1-Math.abs(diff)/0.5)*(1-pd/8)*0.7;lr+=spot;lg+=spot;lb+=spot*1.1;}}
  return[Math.min(2.0,lr),Math.min(2.0,lg),Math.min(2.0,lb)];
}

const LIGHT_CACHE_RES=2;
const lightCache=new Float32Array(MAP_W*LIGHT_CACHE_RES*MAP_H*LIGHT_CACHE_RES*3);
let lightCacheValid=false;

function buildLightCache(){
  for(let gy=0;gy<MAP_H*LIGHT_CACHE_RES;gy++) for(let gx=0;gx<MAP_W*LIGHT_CACHE_RES;gx++){
    const wx=(gx+0.5)/LIGHT_CACHE_RES,wy=(gy+0.5)/LIGHT_CACHE_RES;
    const[lr,lg,lb]=getLightAt(wx,wy);
    const ci=(gy*MAP_W*LIGHT_CACHE_RES+gx)*3;
    lightCache[ci]=lr;lightCache[ci+1]=lg;lightCache[ci+2]=lb;
  }
  lightCacheValid=true;
}

function getCachedLight(wx,wy){
  const gx=Math.floor(wx*LIGHT_CACHE_RES),gy=Math.floor(wy*LIGHT_CACHE_RES);
  if(gx<0||gx>=MAP_W*LIGHT_CACHE_RES||gy<0||gy>=MAP_H*LIGHT_CACHE_RES)return[0.15,0.14,0.18];
  const ci=(gy*MAP_W*LIGHT_CACHE_RES+gx)*3;
  return[lightCache[ci],lightCache[ci+1],lightCache[ci+2]];
}

// ============================================================================
//  PLAYER
// ============================================================================
const player = {
  x:2.5, y:2.5, angle:0, pitch:0,
  health:100, maxHealth:100, shield:100, maxShield:100,
  shieldRegenTimer:0, shieldRegenDelay:3.0, shieldRegenRate:30, shieldFlash:0,
  moveSpeed:4.0, sprintSpeed:6.5, weapon:0,
  weapons: [
    {name:'MA5B ASSAULT RIFLE',ammo:32,maxAmmo:32,reserve:256,fireRate:0.08,damage:12,spread:0.03,auto:true,sound:'shoot'},
    {name:'M6D PISTOL',ammo:12,maxAmmo:12,reserve:120,fireRate:0.3,damage:25,spread:0.01,auto:false,sound:'shoot'},
    {name:'M90 SHOTGUN',ammo:8,maxAmmo:8,reserve:40,fireRate:0.8,damage:60,spread:0.08,auto:false,sound:'shotgun',pellets:6},
  ],
  fireTimer:0, muzzleFlash:0, bobPhase:0, bobAmount:0,
  reloading:false, reloadTimer:0, kills:0, damageDealt:0, damageTaken:0,
  weaponKickback:0, damageFlash:0, shieldRegenSoundCd:0,
  grenades:4, maxGrenades:4, grenadeTimer:0,
};

// ============================================================================
//  ENEMIES
// ============================================================================
const ENEMY_TYPES = {
  grunt:{health:30,speed:1.3,damage:5,fireRate:1.5,range:10,size:0.4,points:100,shootSound:'enemy_shoot'},
  elite:{health:80,speed:1.9,damage:12,fireRate:0.8,range:14,size:0.6,points:250,shootSound:'plasma'},
  hunter:{health:200,speed:0.8,damage:30,fireRate:2.0,range:16,size:0.8,points:500,shootSound:'plasma'},
};
let enemies=[],pickups=[],projectiles=[],particles=[];
let gameRunning=false, gameTime=0;

function createEnemy(type,x,y){const t=ENEMY_TYPES[type];return{type,x,y,health:t.health,maxHealth:t.health,speed:t.speed,damage:t.damage,fireRate:t.fireRate,range:t.range,size:t.size,points:t.points,fireTimer:Math.random()*t.fireRate,state:'idle',alertTimer:0,lastSeen:null,alive:true,animFrame:0,animTimer:0,hitFlash:0,shootSound:t.shootSound};}

function spawnEnemies(){
  if (currentLevel === 'tutorial') { spawnTutorialEnemies(); return; }
  enemies=[];
  const pos={
    grunt:[[5,10],[6,11],[10,5],[13,2],[14,3],[4,13],[7,12],[2,9],[2,10],[20,2],[24,5],[28,3],[22,8],[25,12],[18,7],[29,7],[21,11],[5,16],[7,18],[3,22],[7,24],[15,17],[16,19],[13,22],[16,24],[22,17],[25,19],[28,22],[29,25],[14,28],[15,29]],
    elite:[[10,2],[12,6],[6,5],[24,3],[28,8],[22,12],[5,20],[14,20],[25,22],[4,27],[8,26],[22,27],[28,28],[14,26]],
    hunter:[[13,12],[24,10],[14,24],[28,27]],
  };
  for(const[type,list] of Object.entries(pos))
    for(const[x,y] of list) if(getMap(x|0,y|0)===0) enemies.push(createEnemy(type,x+0.5,y+0.5));
}

function spawnPickups(){
  if (currentLevel === 'tutorial') { spawnTutorialPickups(); return; }
  pickups=[];
  for(const[x,y] of [[4,4],[12,10],[8,20],[24,22],[14,14],[28,15],[6,28]])
    if(getMap(x,y)===0) pickups.push({type:'health',x:x+0.5,y:y+0.5,amount:50,alive:true});
  for(const[x,y] of [[7,7],[14,5],[10,10],[20,6],[26,10],[16,16],[6,25],[24,28],[2,15]])
    if(getMap(x,y)===0) pickups.push({type:'ammo',x:x+0.5,y:y+0.5,weapon:Math.floor(Math.random()*3),alive:true});
  for(const[x,y] of [[3,7],[13,8],[22,20],[28,24],[16,27]])
    if(getMap(x,y)===0) pickups.push({type:'shield',x:x+0.5,y:y+0.5,amount:50,alive:true});
}

// ============================================================================
//  AI TEAMMATES & SQUAD SYSTEM
// ============================================================================
let allies = [];
let squadCommand = 'follow';
let squadCommandTimer = 0;
let squadCommandLabel = '';
let lastVoiceCommand = '';
let voiceCommandTimer = 0;

const ALLY_NAMES = ['SGT. JOHNSON', 'CPL. CHEN', 'PVT. HAYES'];

function createAlly(name, x, y) {
  return {
    name, x, y, health: 100, maxHealth: 100, alive: true,
    angle: 0, speed: 2.2, fireTimer: 0, fireRate: 0.6,
    state: 'follow', target: null, size: 0.5, animFrame: 0, animTimer: 0,
    coverTimer: 0, healCooldown: 0
  };
}

function spawnAllies() {
  allies = [];
  const positions = [[3.5, 2.5], [2.5, 3.5], [3.5, 3.5]];
  for (let i = 0; i < 3; i++) {
    allies.push(createAlly(ALLY_NAMES[i], positions[i][0], positions[i][1]));
  }
}

function issueSquadCommand(cmd) {
  squadCommand = cmd;
  squadCommandTimer = 3;
  const labels = {
    attack: 'ATTACK!', retreat: 'RETREAT!', medic: 'MEDIC!',
    cover: 'COVER ME!', follow: 'FOLLOW ME!', hold: 'HOLD POSITION!', spread: 'SPREAD OUT!'
  };
  squadCommandLabel = labels[cmd] || cmd.toUpperCase();
  lastVoiceCommand = squadCommandLabel;
  voiceCommandTimer = 3;
  playSound('pickup');
  for (const a of allies) {
    if (!a.alive) continue;
    a.state = cmd;
    if (cmd === 'medic') a.healCooldown = 0;
    if (cmd === 'cover') a.coverTimer = 0;
  }
}

function updateAllies(dt) {
  squadCommandTimer = Math.max(0, squadCommandTimer - dt);
  for (const a of allies) {
    if (!a.alive) continue;
    a.animTimer += dt;
    if (a.animTimer > 0.25) { a.animFrame = (a.animFrame + 1) % 4; a.animTimer = 0; }
    const dx = player.x - a.x, dy = player.y - a.y;
    const distToPlayer = Math.sqrt(dx * dx + dy * dy);
    let nearestEnemy = null, nearestDist = Infinity;
    for (const e of enemies) {
      if (!e.alive) continue;
      const ed = Math.sqrt((e.x - a.x) ** 2 + (e.y - a.y) ** 2);
      if (ed < nearestDist && ed < 15) { nearestDist = ed; nearestEnemy = e; }
    }
    switch (a.state) {
      case 'follow': {
        if (distToPlayer > 3) {
          const mx = (dx / distToPlayer) * a.speed * dt;
          const my = (dy / distToPlayer) * a.speed * dt;
          if (canMove(a.x + mx, a.y + my, 0.3)) { a.x += mx; a.y += my; }
          else if (canMove(a.x + mx, a.y, 0.3)) a.x += mx;
          else if (canMove(a.x, a.y + my, 0.3)) a.y += my;
        }
        if (nearestEnemy && nearestDist < 12 && lineOfSight(a.x, a.y, nearestEnemy.x, nearestEnemy.y)) {
          a.angle = Math.atan2(nearestEnemy.y - a.y, nearestEnemy.x - a.x);
          allyFire(a, nearestEnemy, dt);
        } else { a.angle = Math.atan2(dy, dx); }
        break;
      }
      case 'attack': {
        if (nearestEnemy) {
          const edx = nearestEnemy.x - a.x, edy = nearestEnemy.y - a.y;
          a.angle = Math.atan2(edy, edx);
          if (nearestDist > 4) {
            const mx = (edx / nearestDist) * a.speed * 1.3 * dt;
            const my = (edy / nearestDist) * a.speed * 1.3 * dt;
            if (canMove(a.x + mx, a.y + my, 0.3)) { a.x += mx; a.y += my; }
            else if (canMove(a.x + mx, a.y, 0.3)) a.x += mx;
            else if (canMove(a.x, a.y + my, 0.3)) a.y += my;
          }
          if (lineOfSight(a.x, a.y, nearestEnemy.x, nearestEnemy.y)) allyFire(a, nearestEnemy, dt);
        } else {
          if (distToPlayer > 3) {
            const mx = (dx / distToPlayer) * a.speed * dt;
            const my = (dy / distToPlayer) * a.speed * dt;
            if (canMove(a.x + mx, a.y + my, 0.3)) { a.x += mx; a.y += my; }
          }
          a.angle = Math.atan2(dy, dx);
        }
        break;
      }
      case 'retreat': {
        if (distToPlayer > 2) {
          const mx = (dx / distToPlayer) * a.speed * 1.2 * dt;
          const my = (dy / distToPlayer) * a.speed * 1.2 * dt;
          if (canMove(a.x + mx, a.y + my, 0.3)) { a.x += mx; a.y += my; }
          else if (canMove(a.x + mx, a.y, 0.3)) a.x += mx;
          else if (canMove(a.x, a.y + my, 0.3)) a.y += my;
        }
        if (nearestEnemy && nearestDist < 8 && lineOfSight(a.x, a.y, nearestEnemy.x, nearestEnemy.y)) {
          a.angle = Math.atan2(nearestEnemy.y - a.y, nearestEnemy.x - a.x);
          allyFire(a, nearestEnemy, dt);
        } else { a.angle = Math.atan2(dy, dx); }
        break;
      }
      case 'cover': {
        a.coverTimer += dt;
        if (nearestEnemy) {
          const midX = (player.x + nearestEnemy.x) / 2;
          const midY = (player.y + nearestEnemy.y) / 2;
          const toMidDist = Math.sqrt((midX - a.x) ** 2 + (midY - a.y) ** 2);
          if (toMidDist > 1.5) {
            const mx = ((midX - a.x) / toMidDist) * a.speed * dt;
            const my = ((midY - a.y) / toMidDist) * a.speed * dt;
            if (canMove(a.x + mx, a.y + my, 0.3)) { a.x += mx; a.y += my; }
            else if (canMove(a.x + mx, a.y, 0.3)) a.x += mx;
            else if (canMove(a.x, a.y + my, 0.3)) a.y += my;
          }
          a.angle = Math.atan2(nearestEnemy.y - a.y, nearestEnemy.x - a.x);
          if (lineOfSight(a.x, a.y, nearestEnemy.x, nearestEnemy.y)) allyFire(a, nearestEnemy, dt);
        } else {
          if (distToPlayer > 2.5) {
            const mx = (dx / distToPlayer) * a.speed * dt;
            const my = (dy / distToPlayer) * a.speed * dt;
            if (canMove(a.x + mx, a.y + my, 0.3)) { a.x += mx; a.y += my; }
          }
          a.angle = Math.atan2(dy, dx);
        }
        break;
      }
      case 'hold': {
        if (nearestEnemy && nearestDist < 12 && lineOfSight(a.x, a.y, nearestEnemy.x, nearestEnemy.y)) {
          a.angle = Math.atan2(nearestEnemy.y - a.y, nearestEnemy.x - a.x);
          allyFire(a, nearestEnemy, dt);
        }
        break;
      }
      case 'medic': {
        a.healCooldown = Math.max(0, a.healCooldown - dt);
        if (distToPlayer > 1.5) {
          const mx = (dx / distToPlayer) * a.speed * 1.5 * dt;
          const my = (dy / distToPlayer) * a.speed * 1.5 * dt;
          if (canMove(a.x + mx, a.y + my, 0.3)) { a.x += mx; a.y += my; }
          else if (canMove(a.x + mx, a.y, 0.3)) a.x += mx;
          else if (canMove(a.x, a.y + my, 0.3)) a.y += my;
        }
        a.angle = Math.atan2(dy, dx);
        if (distToPlayer < 2 && a.healCooldown <= 0 && player.health < player.maxHealth) {
          player.health = Math.min(player.maxHealth, player.health + 10);
          a.healCooldown = 3;
          playSound('pickup');
          for (let i = 0; i < 5; i++) spawnParticle(player.x, player.y, 0.5, (Math.random()-0.5)*2, (Math.random()-0.5)*2, Math.random()*2, [50,255,100], 0.4, 2);
        }
        if (nearestEnemy && nearestDist < 6 && lineOfSight(a.x, a.y, nearestEnemy.x, nearestEnemy.y)) {
          allyFire(a, nearestEnemy, dt);
        }
        break;
      }
      case 'spread': {
        let pushX = 0, pushY = 0;
        for (const other of allies) {
          if (!other.alive || other === a) continue;
          const odx = a.x - other.x, ody = a.y - other.y;
          const od = Math.sqrt(odx*odx + ody*ody);
          if (od < 4 && od > 0.1) { pushX += (odx/od) * 2; pushY += (ody/od) * 2; }
        }
        if (distToPlayer < 4 && distToPlayer > 0.1) {
          pushX += (-dx/distToPlayer) * 1.5; pushY += (-dy/distToPlayer) * 1.5;
        }
        const pushD = Math.sqrt(pushX*pushX + pushY*pushY);
        if (pushD > 0.1) {
          const mx = (pushX/pushD) * a.speed * 0.8 * dt;
          const my = (pushY/pushD) * a.speed * 0.8 * dt;
          if (canMove(a.x + mx, a.y + my, 0.3)) { a.x += mx; a.y += my; }
        }
        if (nearestEnemy && nearestDist < 12 && lineOfSight(a.x, a.y, nearestEnemy.x, nearestEnemy.y)) {
          a.angle = Math.atan2(nearestEnemy.y - a.y, nearestEnemy.x - a.x);
          allyFire(a, nearestEnemy, dt);
        }
        break;
      }
    }
    for (let i = projectiles.length - 1; i >= 0; i--) {
      const p = projectiles[i];
      if (p.owner !== 'enemy') continue;
      const pdx = p.x - a.x, pdy = p.y - a.y;
      if (pdx * pdx + pdy * pdy < 0.4) {
        a.health -= p.damage;
        projectiles.splice(i, 1);
        for (let j = 0; j < 3; j++) spawnParticle(a.x, a.y, 0.5, (Math.random()-0.5)*3, (Math.random()-0.5)*3, Math.random()*2, [50,200,50], 0.3, 2);
        if (a.health <= 0) { a.alive = false; }
        break;
      }
    }
  }
}

function allyFire(ally, target, dt) {
  ally.fireTimer -= dt;
  if (ally.fireTimer <= 0) {
    ally.fireTimer = ally.fireRate + Math.random() * 0.3;
    const angle = Math.atan2(target.y - ally.y, target.x - ally.x) + (Math.random() - 0.5) * 0.08;
    projectiles.push({
      x: ally.x, y: ally.y, z: 0.3,
      vx: Math.cos(angle) * 8, vy: Math.sin(angle) * 8,
      damage: 12, color: [80, 255, 80], life: 2, owner: 'ally'
    });
    playSound('shoot');
    for (let i = 0; i < 2; i++) spawnParticle(ally.x, ally.y, 0.3, Math.cos(angle)*2+Math.random(), Math.sin(angle)*2+Math.random(), Math.random(), [80,255,80], 0.12, 1.5);
  }
}

// ============================================================================
//  HAND GESTURE CONTROL SYSTEM
// ============================================================================
let handControlActive = false;
let mpHands = null;
let mpFaceMesh = null;
const gestureInput = {
  moveX:0, moveY:0, lookX:0, lookY:0,
  fire:false, reload:false, interact:false, sprint:false, weapon:-1,
  leftDetected:false, rightDetected:false, gestureLabel:'',
  headDetected:false, headX:0, headY:0, headTurnX:0, headTurnY:0,
  throwGrenade:false,
  stopSign:false
};
let smoothLookX=0, smoothLookY=0, smoothMoveX=0, smoothMoveY=0;
let smoothHeadX=0, smoothHeadY=0, smoothHeadTurnX=0, smoothHeadTurnY=0;
let lastGestureFire = false;
let headBaseX=0.5, headBaseY=0.4, headCalibrated=false, headCalibFrames=0;
let prevRightWristY = null, throwCooldown = 0;
let liveGrenades = [];
let currentLevel = 'tutorial';
let tutorialStep = 0;
let tutorialTimer = 0;
let tutorialArrowTarget = null;

function isFingerUp(lm, finger) {
  const tips={thumb:4,index:8,middle:12,ring:16,pinky:20};
  const pips={thumb:3,index:6,middle:10,ring:14,pinky:18};
  const mcps={thumb:2,index:5,middle:9,ring:13,pinky:17};
  if(finger==='thumb') return Math.abs(lm[tips.thumb].x-lm[mcps.thumb].x)>0.06;
  return lm[tips[finger]].y < lm[pips[finger]].y;
}

function countFingers(lm) {
  let c=0;
  for(const f of ['index','middle','ring','pinky']) if(isFingerUp(lm,f)) c++;
  return c;
}

function isPinch(lm) {
  const dx=lm[4].x-lm[8].x, dy=lm[4].y-lm[8].y;
  return Math.sqrt(dx*dx+dy*dy) < 0.065;
}

function onHandResults(results) {
  let leftLM=null, rightLM=null;
  if(results.multiHandLandmarks && results.multiHandedness) {
    for(let i=0; i<results.multiHandLandmarks.length; i++) {
      const lm=results.multiHandLandmarks[i];
      const label=results.multiHandedness[i].label;
      // MediaPipe mirrors: 'Left' label = user's right hand
      if(label==='Left') rightLM=lm; else leftLM=lm;
    }
  }

  gestureInput.leftDetected = !!leftLM;
  gestureInput.rightDetected = !!rightLM;
  let labels = [];

  // Detect STOP SIGN on either hand (open palm, all fingers spread, palm facing camera)
  function isStopSign(lm) {
    const allUp = countFingers(lm) >= 4 && isFingerUp(lm, 'thumb');
    if (!allUp) return false;
    // Check palm is relatively flat/facing camera: fingertips roughly same x-spread
    const wrist = lm[0], middle = lm[12];
    const palmHeight = Math.abs(wrist.y - middle.y);
    return palmHeight > 0.12; // hand is upright, fingers pointing up = stop sign
  }

  // Check for stop sign on ANY detected hand
  gestureInput.stopSign = false;
  if (leftLM && isStopSign(leftLM)) { gestureInput.stopSign = true; labels.push('üõë STOP'); }
  if (rightLM && isStopSign(rightLM)) { gestureInput.stopSign = true; if(!labels.includes('üõë STOP')) labels.push('üõë STOP'); }

  // LEFT HAND ‚Üí Grenade only (movement is now face-driven)
  if(leftLM) {
    gestureInput.leftDetected = true;
    const fingers = countFingers(leftLM);
    const thumbUp = isFingerUp(leftLM, 'thumb');
    gestureInput.weapon = -1;
    gestureInput.sprint = false;
    // Fist = sprint boost (when moving via face)
    if (fingers === 0 && !thumbUp) {
      gestureInput.sprint = true;
      labels.push('SPRINT');
    }
    // Open palm on left = throw grenade (only if NOT stop sign, so we differentiate)
    // Grenade: quick open-close. Stop sign: hold still with hand up.
    // Use: left hand open palm while right hand is also detected = grenade (not stop)
    if (fingers >= 4 && thumbUp && throwCooldown <= 0 && !gestureInput.stopSign) {
      gestureInput.throwGrenade = true;
      throwCooldown = 1.5;
      labels.push('üß®THROW');
    }
  } else {
    gestureInput.sprint=false; gestureInput.weapon=-1;
  }
  // Face movement values are set in onFaceResults, not here
  gestureInput.moveX = 0; gestureInput.moveY = 0;

  // RIGHT HAND ‚Üí Aim & Actions
  if(rightLM) {
    const wrist=rightLM[0];
    const rawLX = (wrist.x-0.5)*-3.0;
    const rawLY = (wrist.y-0.5)*-3.0;
    const deadZone = 0.15;
    gestureInput.lookX = Math.abs(rawLX)<deadZone ? 0 : rawLX;
    gestureInput.lookY = Math.abs(rawLY)<deadZone ? 0 : rawLY;

    gestureInput.fire = isPinch(rightLM);
    const fingers = countFingers(rightLM);
    gestureInput.reload = (fingers>=4 && isFingerUp(rightLM,'thumb'));
    gestureInput.interact = (isFingerUp(rightLM,'index') && isFingerUp(rightLM,'middle')
      && !isFingerUp(rightLM,'ring') && !isFingerUp(rightLM,'pinky'));

    if(gestureInput.fire) labels.push('FIRE');
    else if(gestureInput.reload) labels.push('RELOAD');
    else if(gestureInput.interact) labels.push('INTERACT');
    labels.push('AIM');
  } else {
    gestureInput.lookX=0; gestureInput.lookY=0;
    gestureInput.fire=false; gestureInput.reload=false; gestureInput.interact=false;
  }

  gestureInput.gestureLabel = labels.join(' | ');
  drawCamPreview(results);
}

function onFaceResults(results) {
  if (results.multiFaceLandmarks && results.multiFaceLandmarks.length > 0) {
    const lm = results.multiFaceLandmarks[0];
    gestureInput.headDetected = true;
    const nose = lm[1];
    // Calibrate head center position over first 30 frames
    if (!headCalibrated) {
      headCalibFrames++;
      headBaseX = headBaseX * 0.9 + nose.x * 0.1;
      headBaseY = headBaseY * 0.9 + nose.y * 0.1;
      if (headCalibFrames > 30) headCalibrated = true;
    }
    // FACE TILT = MOVEMENT DIRECTION
    // Use forehead-to-chin pitch angle for forward/back (tilt head forward = walk forward)
    const forehead = lm[10], chin = lm[152];
    const leftTemple = lm[234], rightTemple = lm[454];
    const faceHeight = Math.abs(chin.y - forehead.y) + 0.01;
    const faceWidth = Math.abs(rightTemple.x - leftTemple.x) + 0.01;
    // Pitch: when you tilt forward, chin moves down (larger y) relative to forehead
    // facePitch > 0 means tilting forward
    const facePitchRaw = (chin.x - forehead.x); // horizontal offset = tilt forward/back sign
    const facePitch = (nose.y - headBaseY) * 5.0; // positive when head goes down (tilting forward)
    // Strafe: face position left/right of calibrated center
    const faceStrafe = (nose.x - headBaseX) * -5.0;
    gestureInput.headX = faceStrafe;
    gestureInput.headY = facePitch; // POSITIVE = tilted forward = walk forward
    // Head turn ‚Üí look/aim direction
    const faceCenterX = (leftTemple.x + rightTemple.x) / 2;
    gestureInput.headTurnX = (nose.x - faceCenterX) / faceWidth * -3.0;
    const faceMidY = (forehead.y + chin.y) / 2;
    gestureInput.headTurnY = (nose.y - faceMidY) / faceHeight * -2.0;
  } else {
    gestureInput.headDetected = false;
    gestureInput.headX = 0; gestureInput.headY = 0;
    gestureInput.headTurnX = 0; gestureInput.headTurnY = 0;
  }
}

function drawCamPreview(results) {
  const camCvs = document.getElementById('cam-preview');
  const camCtx = camCvs.getContext('2d');
  const video = document.getElementById('camera-feed');
  camCtx.save();
  camCtx.translate(camCvs.width, 0);
  camCtx.scale(-1, 1); // Mirror
  camCtx.drawImage(video, 0, 0, camCvs.width, camCvs.height);
  camCtx.restore();

  // Draw hand skeletons
  if(results.multiHandLandmarks) {
    for(const lm of results.multiHandLandmarks) {
      const conns = [[0,1],[1,2],[2,3],[3,4],[0,5],[5,6],[6,7],[7,8],[5,9],[9,10],[10,11],[11,12],[9,13],[13,14],[14,15],[15,16],[13,17],[17,18],[18,19],[19,20],[0,17]];
      camCtx.strokeStyle='rgba(0,255,128,0.7)'; camCtx.lineWidth=1;
      for(const[a,b] of conns) {
        const ax=(1-lm[a].x)*camCvs.width, ay=lm[a].y*camCvs.height;
        const bx=(1-lm[b].x)*camCvs.width, by=lm[b].y*camCvs.height;
        camCtx.beginPath(); camCtx.moveTo(ax,ay); camCtx.lineTo(bx,by); camCtx.stroke();
      }
      for(const pt of lm) {
        camCtx.fillStyle='#0f8'; camCtx.beginPath();
        camCtx.arc((1-pt.x)*camCvs.width, pt.y*camCvs.height, 2, 0, Math.PI*2); camCtx.fill();
      }
    }
  }

  // Dead zone circle
  camCtx.strokeStyle='rgba(255,255,255,0.15)'; camCtx.lineWidth=1;
  camCtx.beginPath(); camCtx.arc(camCvs.width/2, camCvs.height/2, 15, 0, Math.PI*2); camCtx.stroke();

  // Draw head tracking indicator
  if (gestureInput.headDetected) {
    const hx = camCvs.width/2 + gestureInput.headX * -12;
    const hy = camCvs.height/2 + gestureInput.headY * -12;
    camCtx.strokeStyle = 'rgba(255,200,60,0.7)'; camCtx.lineWidth = 2;
    camCtx.beginPath(); camCtx.arc(hx, hy, 18, 0, Math.PI*2); camCtx.stroke();
    camCtx.strokeStyle = 'rgba(255,200,60,0.3)'; camCtx.lineWidth = 1;
    camCtx.beginPath(); camCtx.moveTo(hx-8,hy); camCtx.lineTo(hx+8,hy); camCtx.moveTo(hx,hy-8); camCtx.lineTo(hx,hy+8); camCtx.stroke();
    camCtx.fillStyle='rgba(255,200,60,0.5)'; camCtx.font='bold 8px monospace'; camCtx.textAlign='center';
    camCtx.fillText('HEAD', hx, hy+28);
  }

  // Update gesture label
  const labelEl = document.getElementById('gesture-label');
  let statusText = gestureInput.gestureLabel || (gestureInput.leftDetected||gestureInput.rightDetected?'':'NO HANDS');
  if (gestureInput.headDetected) statusText = 'HEAD ' + (headCalibrated?'OK':'CAL') + (statusText?' | ':' ') + statusText;
  labelEl.textContent = statusText;

  // Also draw to overlay preview if visible
  const overlayPrev = document.getElementById('overlay-cam-preview');
  const overlayWrap = document.getElementById('overlay-preview-wrap');
  if(overlayWrap && overlayWrap.style.display === 'flex') {
    const oCtx = overlayPrev.getContext('2d');
    oCtx.drawImage(camCvs, 0, 0, overlayPrev.width, overlayPrev.height);
    document.getElementById('overlay-gesture-label').textContent = statusText;
  }
}

async function enumerateCameras() {
  try {
    // Request a temporary stream to trigger permission prompt so labels become available
    const tempStream = await navigator.mediaDevices.getUserMedia({video:true});
    tempStream.getTracks().forEach(t => t.stop());
  } catch(e) { /* permission denied or no camera ‚Äî selector stays empty */ }
  const devices = await navigator.mediaDevices.enumerateDevices();
  const videoDevices = devices.filter(d => d.kind === 'videoinput');
  const selector = document.getElementById('cam-selector');
  selector.innerHTML = '';
  if (videoDevices.length === 0) {
    selector.innerHTML = '<option value="">No cameras found</option>';
    return;
  }
  videoDevices.forEach((dev, i) => {
    const opt = document.createElement('option');
    opt.value = dev.deviceId;
    opt.textContent = dev.label || ('Camera ' + (i+1));
    selector.appendChild(opt);
  });
}

let previewActive = false;

async function startOverlayPreview() {
  const statusEl = document.getElementById('cam-status');
  const btn = document.getElementById('btn-preview-cam');
  if(previewActive) return; // already running
  statusEl.textContent = 'Starting camera preview...';
  btn.textContent = 'Loading...';
  try {
    const selectedId = document.getElementById('cam-selector').value;
    const videoConstraints = selectedId
      ? { deviceId: { exact: selectedId }, width:{ideal:640}, height:{ideal:480} }
      : { width:{ideal:640}, height:{ideal:480}, facingMode:'user' };
    const stream = await navigator.mediaDevices.getUserMedia({ video: videoConstraints });
    const video = document.getElementById('camera-feed');
    video.srcObject = stream;
    await video.play();

    statusEl.textContent = 'Loading hand tracking model...';

    mpHands = new Hands({
      locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`
    });
    mpHands.setOptions({
      maxNumHands: 2, modelComplexity: 1,
      minDetectionConfidence: 0.65, minTrackingConfidence: 0.5
    });
    mpHands.onResults(onHandResults);
    await mpHands.send({image: video});

    statusEl.textContent = 'Loading face tracking model...';
    mpFaceMesh = new FaceMesh({
      locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/${file}`
    });
    mpFaceMesh.setOptions({ maxNumFaces: 1, refineLandmarks: false, minDetectionConfidence: 0.5, minTrackingConfidence: 0.5 });
    mpFaceMesh.onResults(onFaceResults);
    await mpFaceMesh.send({image: video});

    handControlActive = true;
    previewActive = true;
    headCalibrated = false; headCalibFrames = 0;

    // Start tracking loop at ~15fps
    setInterval(() => {
      if(video.readyState >= 2 && handControlActive) {
        mpHands.send({image: video});
        mpFaceMesh.send({image: video});
      }
    }, 66);

    document.getElementById('cam-preview').style.display = 'block';
    document.getElementById('gesture-label').style.display = 'block';
    document.getElementById('overlay-preview-wrap').style.display = 'flex';
    btn.textContent = '\u2705 Camera Active';
    btn.classList.add('active');
    statusEl.textContent = 'Hand tracking active ‚Äî try moving your hands!';
  } catch(err) {
    statusEl.textContent = 'Camera failed: ' + err.message;
    btn.textContent = '\uD83D\uDCF9 Preview Camera';
  }
}

async function initHandTracking() {
  const statusEl = document.getElementById('cam-status');
  // If preview was already started, just return success
  if(previewActive && handControlActive) {
    document.getElementById('overlay-preview-wrap').style.display = 'none';
    statusEl.textContent = '';
    return true;
  }
  statusEl.textContent = 'Requesting camera & microphone access...';
  try {
    const selectedId = document.getElementById('cam-selector').value;
    const videoConstraints = selectedId
      ? { deviceId: { exact: selectedId }, width:{ideal:640}, height:{ideal:480} }
      : { width:{ideal:640}, height:{ideal:480}, facingMode:'user' };
    // Request BOTH video and audio in one prompt so browser combines permission dialog
    const stream = await navigator.mediaDevices.getUserMedia({ video: videoConstraints, audio: true });
    const video = document.getElementById('camera-feed');
    // Only the video tracks go to the video element
    const videoOnlyStream = new MediaStream(stream.getVideoTracks());
    video.srcObject = videoOnlyStream;
    // Stop audio tracks now ‚Äî SpeechRecognition will manage its own mic access later
    stream.getAudioTracks().forEach(t => t.stop());
    await video.play();

    statusEl.textContent = 'Loading hand tracking model...';

    mpHands = new Hands({
      locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`
    });
    mpHands.setOptions({
      maxNumHands: 2, modelComplexity: 1,
      minDetectionConfidence: 0.65, minTrackingConfidence: 0.5
    });
    mpHands.onResults(onHandResults);

    // Wait for model to load by sending first frame
    await mpHands.send({image: video});

    statusEl.textContent = 'Loading face tracking model...';
    mpFaceMesh = new FaceMesh({
      locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/${file}`
    });
    mpFaceMesh.setOptions({ maxNumFaces: 1, refineLandmarks: false, minDetectionConfidence: 0.5, minTrackingConfidence: 0.5 });
    mpFaceMesh.onResults(onFaceResults);
    await mpFaceMesh.send({image: video});
    headCalibrated = false; headCalibFrames = 0;

    // Start tracking loop at ~15fps
    setInterval(() => {
      if(video.readyState >= 2 && handControlActive) {
        mpHands.send({image: video});
        mpFaceMesh.send({image: video});
      }
    }, 66);

    handControlActive = true;
    document.getElementById('cam-preview').style.display = 'block';
    document.getElementById('gesture-label').style.display = 'block';
    document.getElementById('overlay-preview-wrap').style.display = 'none';
    statusEl.textContent = '';
    return true;
  } catch(err) {
    statusEl.textContent = 'Camera failed: ' + err.message + ' ‚Äî Falling back to keyboard';
    console.warn('Camera init failed:', err);
    return false;
  }
}

// ============================================================================
//  VOICE CONTROL SYSTEM
// ============================================================================
let voiceActive = false;
let voiceRecognition = null;

const VOICE_COMMANDS = {
  'assault rifle': () => { player.weapon = 0; lastVoiceCommand = 'ASSAULT RIFLE'; voiceCommandTimer = 2; playSound('pickup'); },
  'rifle': () => { player.weapon = 0; lastVoiceCommand = 'ASSAULT RIFLE'; voiceCommandTimer = 2; playSound('pickup'); },
  'pistol': () => { player.weapon = 1; lastVoiceCommand = 'PISTOL'; voiceCommandTimer = 2; playSound('pickup'); },
  'shotgun': () => { player.weapon = 2; lastVoiceCommand = 'SHOTGUN'; voiceCommandTimer = 2; playSound('pickup'); },
  'reload': () => { startReload(); lastVoiceCommand = 'RELOAD'; voiceCommandTimer = 2; },
  'grenade': () => { gestureInput.throwGrenade = true; lastVoiceCommand = 'üß® GRENADE'; voiceCommandTimer = 2; },
  'throw': () => { gestureInput.throwGrenade = true; lastVoiceCommand = 'üß® THROW'; voiceCommandTimer = 2; },
  'cover me': () => { issueSquadCommand('cover'); },
  'follow me': () => { issueSquadCommand('follow'); },
  'hold position': () => { issueSquadCommand('hold'); },
  'spread out': () => { issueSquadCommand('spread'); },
  'attack': () => { issueSquadCommand('attack'); },
  'retreat': () => { issueSquadCommand('retreat'); },
  'medic': () => { issueSquadCommand('medic'); },
  'follow': () => { issueSquadCommand('follow'); },
  'hold': () => { issueSquadCommand('hold'); },
};

async function initVoice() {
  const SR = window.SpeechRecognition || window.webkitSpeechRecognition;
  if (!SR) { console.warn('Speech recognition not supported'); return; }
  // Explicitly request microphone permission so the browser prompts
  try {
    const micStream = await navigator.mediaDevices.getUserMedia({ audio: true });
    // Stop the stream tracks - SpeechRecognition manages its own mic access
    micStream.getTracks().forEach(t => t.stop());
  } catch (err) {
    console.warn('Microphone permission denied:', err.message);
    return;
  }
  voiceRecognition = new SR();
  voiceRecognition.continuous = true;
  voiceRecognition.interimResults = false;
  voiceRecognition.lang = 'en-US';
  voiceRecognition.onresult = (event) => {
    for (let i = event.resultIndex; i < event.results.length; i++) {
      if (event.results[i].isFinal) {
        const transcript = event.results[i][0].transcript.trim().toLowerCase();
        processVoiceCommand(transcript);
      }
    }
  };
  voiceRecognition.onerror = (e) => { if (e.error !== 'no-speech') console.warn('Voice error:', e.error); };
  voiceRecognition.onend = () => { if (voiceActive && gameRunning) voiceRecognition.start(); };
  voiceActive = true;
  voiceRecognition.start();
}

function processVoiceCommand(transcript) {
  const sorted = Object.keys(VOICE_COMMANDS).sort((a,b) => b.length - a.length);
  for (const cmd of sorted) {
    if (transcript.includes(cmd)) {
      VOICE_COMMANDS[cmd]();
      return;
    }
  }
}

function startReload() {
  const w = player.weapons[player.weapon];
  if (!player.reloading && w.reserve > 0 && w.ammo < w.maxAmmo) {
    player.reloading = true;
    player.reloadTimer = 1.5;
    playSound('reload');
  }
}

// ============================================================================
//  KEYBOARD & MOUSE INPUT (fallback)
// ============================================================================
const keys={};
let mouseDX=0, mouseDY=0, mouseDown=false, mouseLocked=false;
document.addEventListener('keydown',e=>{keys[e.code]=true;e.preventDefault();});
document.addEventListener('keyup',e=>{keys[e.code]=false;});
document.addEventListener('mousedown',e=>{if(e.button===0)mouseDown=true;});
document.addEventListener('mouseup',e=>{if(e.button===0)mouseDown=false;});
document.addEventListener('mousemove',e=>{if(mouseLocked){mouseDX+=e.movementX;mouseDY+=e.movementY;}});
document.addEventListener('pointerlockchange',()=>{mouseLocked=document.pointerLockElement===canvas;});

// ============================================================================
//  RAYCASTING
// ============================================================================
function castRay(ox,oy,angle){
  const dirX=Math.cos(angle),dirY=Math.sin(angle);
  let mapX=Math.floor(ox),mapY=Math.floor(oy);
  const ddx=Math.abs(1/dirX),ddy=Math.abs(1/dirY);
  let stepX,stepY,sdx,sdy;
  if(dirX<0){stepX=-1;sdx=(ox-mapX)*ddx;}else{stepX=1;sdx=(mapX+1-ox)*ddx;}
  if(dirY<0){stepY=-1;sdy=(oy-mapY)*ddy;}else{stepY=1;sdy=(mapY+1-oy)*ddy;}
  let side=0,hit=0,steps=0;
  while(hit===0&&steps++<64){
    if(sdx<sdy){sdx+=ddx;mapX+=stepX;side=0;}else{sdy+=ddy;mapY+=stepY;side=1;}
    const t=getMap(mapX,mapY); if(t>0) hit=t;
  }
  const perpDist=side===0?sdx-ddx:sdy-ddy;
  let wallX=side===0?oy+perpDist*dirY:ox+perpDist*dirX;
  wallX-=Math.floor(wallX);
  return{dist:perpDist,side,tile:hit,wallX,mapX,mapY};
}

// ============================================================================
//  RENDERING
// ============================================================================
function renderScene(){
  const fov=Math.PI/3, halfH=RENDER_H/2, pitchOff=player.pitch*250;
  buf.fill(0);
  if(!lightCacheValid) buildLightCache();

  for(let x=0;x<RENDER_W;x++){
    const rayAngle=player.angle-fov/2+(x/RENDER_W)*fov;
    const ray=castRay(player.x,player.y,rayAngle);
    zBuffer[x]=ray.dist;
    if(ray.dist<0.001) continue;

    const lineH=RENDER_H/ray.dist;
    const wallStartY=Math.floor(-lineH/2+halfH+pitchOff);
    const wallEndY=Math.floor(lineH/2+halfH+pitchOff);
    const ds=Math.max(0,wallStartY), de=Math.min(RENDER_H-1,wallEndY);

    // Door texture sliding
    let texName=wallTexMap[ray.tile]||'metal';
    let doorSlide=0;
    if(getRawMap(ray.mapX,ray.mapY)===3){
      texName='door';
      const d=doors.get(doorKey(ray.mapX,ray.mapY));
      if(d) { doorSlide=d.openAmount; if(d.openAmount>0.9) continue; /* fully open, skip wall */ }
    }

    const tex=textures[texName];
    let texX=Math.floor((ray.wallX+doorSlide)*TEX_SIZE)%TEX_SIZE;
    if(texX<0) texX+=TEX_SIZE;
    if(texX>=TEX_SIZE) texX=TEX_SIZE-1;

    const step=TEX_SIZE/lineH;
    let texPos=ds>wallStartY?(ds-wallStartY)*step:0;

    const hitX=player.x+ray.dist*Math.cos(rayAngle);
    const hitY=player.y+ray.dist*Math.sin(rayAngle);
    const[lr,lg,lb]=getLightAt(hitX,hitY);
    const sideMul=ray.side===1?0.75:1.0;
    const fogFactor=1-Math.exp(-ray.dist*0.08);

    for(let y=ds;y<=de;y++){
      const texY=Math.floor(texPos)&(TEX_SIZE-1); texPos+=step;
      const ti=(texY*TEX_SIZE+texX)*4;
      let r=tex[ti]*lr*sideMul,g=tex[ti+1]*lg*sideMul,b=tex[ti+2]*lb*sideMul;
      r=r*(1-fogFactor)+8*fogFactor; g=g*(1-fogFactor)+5*fogFactor; b=b*(1-fogFactor)+18*fogFactor;
      const pi=(y*RENDER_W+x)*4;
      buf[pi]=Math.max(0,Math.min(255,r|0)); buf[pi+1]=Math.max(0,Math.min(255,g|0));
      buf[pi+2]=Math.max(0,Math.min(255,b|0)); buf[pi+3]=255;
    }

    const rayDirX=Math.cos(rayAngle),rayDirY=Math.sin(rayAngle);

    // Floor
    for(let y=de+1;y<RENDER_H;y++){
      const rowDist=RENDER_H/(2.0*(y-halfH-pitchOff));
      if(rowDist<0||rowDist>30) continue;
      const floorX=player.x+rayDirX*rowDist, floorY=player.y+rayDirY*rowDist;
      const ftx=Math.floor(floorX*TEX_SIZE)&(TEX_SIZE-1), fty=Math.floor(floorY*TEX_SIZE)&(TEX_SIZE-1);
      const fmi=Math.floor(floorY)*MAP_W+Math.floor(floorX);
      const ftype=(fmi>=0&&fmi<MAP_W*MAP_H)?floorTypeMap[fmi]:0;
      const floorTex=textures[floorTexNames[ftype]];
      const fi=(fty*TEX_SIZE+ftx)*4;
      const[flr,flg,flb]=getCachedLight(floorX,floorY);
      const ff=1-Math.exp(-rowDist*0.09);
      let r=floorTex[fi]*flr,g=floorTex[fi+1]*flg,b=floorTex[fi+2]*flb;
      r=r*(1-ff)+8*ff;g=g*(1-ff)+5*ff;b=b*(1-ff)+18*ff;
      const pi=(y*RENDER_W+x)*4;
      buf[pi]=Math.max(0,Math.min(255,r|0));buf[pi+1]=Math.max(0,Math.min(255,g|0));
      buf[pi+2]=Math.max(0,Math.min(255,b|0));buf[pi+3]=255;
    }

    // Ceiling
    const ceilTex=textures['ceiling'];
    for(let y=0;y<ds;y++){
      const rowDist=RENDER_H/(2.0*(halfH+pitchOff-y));
      if(rowDist<0||rowDist>30) continue;
      const ceilX=player.x+rayDirX*rowDist,ceilY=player.y+rayDirY*rowDist;
      const ctx2=Math.floor(ceilX*TEX_SIZE)&(TEX_SIZE-1),cty=Math.floor(ceilY*TEX_SIZE)&(TEX_SIZE-1);
      const ci=(cty*TEX_SIZE+ctx2)*4;
      const[clr,clg,clb]=getCachedLight(ceilX,ceilY);
      const cf=1-Math.exp(-rowDist*0.1);
      let r=ceilTex[ci]*clr,g=ceilTex[ci+1]*clg,b=ceilTex[ci+2]*clb;
      r=r*(1-cf)+3*cf;g=g*(1-cf)+3*cf;b=b*(1-cf)+8*cf;
      const pi=(y*RENDER_W+x)*4;
      buf[pi]=Math.max(0,Math.min(255,r|0));buf[pi+1]=Math.max(0,Math.min(255,g|0));
      buf[pi+2]=Math.max(0,Math.min(255,b|0));buf[pi+3]=255;
    }
  }
}

// ============================================================================
//  SPRITES
// ============================================================================
function renderSprites(){
  const halfH=RENDER_H/2,pitchOff=player.pitch*250,fov=Math.PI/3;
  const spriteList=[];
  for(const e of enemies){if(!e.alive) continue;const dx=e.x-player.x,dy=e.y-player.y;spriteList.push({x:e.x,y:e.y,dist:Math.sqrt(dx*dx+dy*dy),type:'enemy',ref:e});}
  for(const p of pickups){if(!p.alive) continue;const dx=p.x-player.x,dy=p.y-player.y;spriteList.push({x:p.x,y:p.y,dist:Math.sqrt(dx*dx+dy*dy),type:'pickup',ref:p});}
  for(const a of allies){if(!a.alive) continue;const dx=a.x-player.x,dy=a.y-player.y;spriteList.push({x:a.x,y:a.y,dist:Math.sqrt(dx*dx+dy*dy),type:'ally',ref:a});}
  for(const p of projectiles){const dx=p.x-player.x,dy=p.y-player.y;spriteList.push({x:p.x,y:p.y,dist:Math.sqrt(dx*dx+dy*dy),type:'proj',ref:p});}
  for(const g of liveGrenades){const dx=g.x-player.x,dy=g.y-player.y;spriteList.push({x:g.x,y:g.y,dist:Math.sqrt(dx*dx+dy*dy),type:'grenade',ref:g});}
  spriteList.sort((a,b)=>b.dist-a.dist);

  for(const spr of spriteList){
    const dx=spr.x-player.x,dy=spr.y-player.y;
    let relAngle=Math.atan2(dy,dx)-player.angle;
    while(relAngle>Math.PI)relAngle-=2*Math.PI;while(relAngle<-Math.PI)relAngle+=2*Math.PI;
    if(Math.abs(relAngle)>fov*0.7) continue; if(spr.dist<0.3) continue;
    const screenX=Math.floor(RENDER_W/2+(relAngle/fov)*RENDER_W);
    const[lr,lg,lb]=getLightAt(spr.x,spr.y);
    const fogF=1-Math.exp(-spr.dist*0.08);
    if(spr.type==='enemy') renderEnemy(spr.ref,screenX,spr.dist,halfH,pitchOff,lr,lg,lb,fogF);
    else if(spr.type==='ally') renderAlly(spr.ref,screenX,spr.dist,halfH,pitchOff,lr,lg,lb,fogF);
    else if(spr.type==='pickup') renderPickup(spr.ref,screenX,spr.dist,halfH,pitchOff,lr,lg,lb,fogF);
    else if(spr.type==='grenade') renderGrenade(spr.ref,screenX,spr.dist,halfH,pitchOff,fogF);
    else renderProjectile(spr.ref,screenX,spr.dist,halfH,pitchOff,fogF);
  }
}

// ============================================================================
//  AWESOME ENEMY RENDERING
// ============================================================================
function renderEnemy(e, screenX, dist, halfH, pitchOff, lr, lg, lb, fogF) {
  const sprH = Math.floor((RENDER_H / dist) * e.size);
  if (sprH < 2) return;
  const sprW = Math.floor(sprH * (e.type==='hunter'?1.3:e.type==='elite'?0.75:0.85));
  const startX = Math.floor(screenX - sprW/2);
  const startY = Math.floor(halfH - sprH/2 + pitchOff);
  const breathe = Math.sin(gameTime*2.5 + e.x*7) * 0.015;
  const walkBob = e.state==='chase' ? Math.sin(gameTime*8+e.y*5)*0.03 : 0;

  for (let sy = 0; sy < sprH; sy++) {
    for (let sx = 0; sx < sprW; sx++) {
      const px = startX + sx, py = startY + sy;
      if (px < 0 || px >= RENDER_W || py < 0 || py >= RENDER_H) continue;
      if (dist > zBuffer[px]) continue;

      const nx = (sx / sprW - 0.5) * 2;
      const ny = (sy / sprH - 0.5) * 2 + breathe + walkBob;
      let r = 0, g = 0, b = 0, draw = false;

      if (e.type === 'grunt') {
        // Triangular hunched body
        const widthAtY = ny < -0.2 ? 0.35+ny*0.3 : ny < 0.3 ? 0.55+ny*0.15 : 0.65-Math.max(0,ny-0.3)*0.8;
        if (Math.abs(nx) < widthAtY && ny > -0.55 && ny < 0.8) {
          draw = true;
          const nz = Math.sqrt(Math.max(0, 1 - (nx/widthAtY)**2 - ny*ny*0.3));
          const shade = Math.max(0.2, nz*0.5+0.5);
          const spec = Math.pow(Math.max(0, nz*0.7-nx*0.4), 6)*0.4;
          const rim = Math.pow(1-Math.abs(nz), 3)*0.5;
          // Head region
          if (ny < -0.15) {
            r=180*shade+spec*120+rim*80; g=120*shade+spec*80+rim*50; b=40*shade+spec*40+rim*30;
            // Eyes
            if (ny>-0.4 && ny<-0.25 && (Math.abs(nx-0.06)<0.04 || Math.abs(nx+0.06)<0.04)) {
              const pulse = 0.7+Math.sin(gameTime*5)*0.3;
              r=255*pulse; g=160*pulse; b=0;
            }
            // Mask/respirator
            if (ny>-0.2 && ny<-0.05 && Math.abs(nx)<0.2) {
              r=60*shade; g=60*shade; b=70*shade;
            }
          }
          // Torso armor
          else if (ny < 0.3) {
            r=200*shade+spec*100; g=130*shade+spec*60; b=40*shade+spec*30;
            // Armor panel lines
            if (Math.abs(Math.sin(ny*20))<0.08) { r*=0.6; g*=0.6; b*=0.6; }
            // Methane tank on back (offset right since we see from front)
            if (nx > 0.15 && ny > 0 && ny < 0.25 && Math.abs(nx-0.25)<0.08) {
              r=100*shade; g=180*shade; b=220*shade;
              const tankGlow = 0.6+Math.sin(gameTime*3)*0.4;
              g+=40*tankGlow; b+=40*tankGlow;
            }
          }
          // Legs
          else {
            if (Math.abs(nx) < 0.06) draw = false;
            else { r=160*shade; g=100*shade; b=30*shade; }
          }
          // Weapon (plasma pistol)
          if (ny > -0.05 && ny < 0.2 && nx > 0.2 && nx < 0.45) {
            draw = true; r=50*shade; g=80*shade; b=50*shade;
            if (nx > 0.38 && ny > 0.05 && ny < 0.12) {
              const glow2 = 0.7+Math.sin(gameTime*6)*0.3;
              r=20; g=200*glow2; b=80*glow2;
            }
          }
          // Rim light
          if (draw && Math.abs(Math.abs(nx)-widthAtY)<0.04) { r+=rim*120; g+=rim*80; b+=rim*50; }
        }

      } else if (e.type === 'elite') {
        // Tall angular warrior
        let widthAtY;
        if (ny < -0.4) widthAtY = 0.2+Math.max(0,ny+0.5)*0.6; // Head crest
        else if (ny < -0.15) widthAtY = 0.35; // Neck/head
        else if (ny < 0.15) widthAtY = 0.5+ny*0.3; // Broad shoulders
        else if (ny < 0.45) widthAtY = 0.55-ny*0.15;  // Tapered waist
        else widthAtY = 0.5-Math.max(0,ny-0.45)*1.2; // Legs

        if (Math.abs(nx) < widthAtY && ny > -0.6 && ny < 0.85) {
          draw = true;
          const nz = Math.sqrt(Math.max(0, 1-(nx/widthAtY)**2-ny*ny*0.2));
          const shade = Math.max(0.15, nz*0.5+0.5);
          const spec = Math.pow(Math.max(0,nz*0.8-nx*0.3),8)*0.5;
          const rim = Math.pow(1-Math.abs(nz),3)*0.6;

          // Head crest
          if (ny < -0.3) {
            r=80*shade+spec*100; g=40*shade+spec*60; b=150*shade+spec*180;
            // Angular crest highlight
            if (ny < -0.4 && Math.abs(nx) < 0.08) { r+=80; g+=30; b+=120; }
          }
          // Head/mandibles
          else if (ny < -0.1) {
            r=90*shade; g=45*shade; b=170*shade;
            // Mandible jaw (split)
            if (ny > -0.2 && ny < -0.1) {
              if (Math.abs(nx-0.08)<0.03 || Math.abs(nx+0.08)<0.03) {
                const mGlow = 0.6+Math.sin(gameTime*4)*0.4;
                r=120*mGlow; g=60*mGlow; b=220*mGlow;
              }
              if (Math.abs(nx) < 0.02) draw = false; // Gap between mandibles
            }
            // Eyes
            if (ny>-0.28 && ny<-0.2 && (Math.abs(nx-0.07)<0.03 || Math.abs(nx+0.07)<0.03)) {
              r=200; g=100; b=255;
            }
          }
          // Shoulder armor
          else if (ny < 0.15) {
            r=110*shade+spec*120; g=55*shade+spec*80; b=200*shade+spec*200;
            if (Math.abs(Math.sin(ny*15+nx*10))<0.06) { r*=0.7; g*=0.7; b*=0.7; }
            // Shoulder plate edges
            if (ny < 0 && Math.abs(Math.abs(nx)-0.35)<0.04) { r+=60; g+=20; b+=100; }
          }
          // Body
          else if (ny < 0.45) {
            r=80*shade+spec*80; g=40*shade+spec*50; b=160*shade+spec*160;
            if (Math.abs(Math.sin(ny*18))<0.05) { r*=0.65; g*=0.65; b*=0.65; }
          }
          // Legs
          else {
            if (Math.abs(nx) < 0.05) draw = false;
            else { r=70*shade; g=35*shade; b=130*shade; }
          }

          // Energy sword (left side)
          if (ny > -0.1 && ny < 0.35 && nx < -0.2 && nx > -0.7) {
            const bladeT = (nx+0.7)/0.5;
            const bladeW = 0.06 * (1-bladeT*0.7);
            if (Math.abs(ny-0.1) < bladeW) {
              draw = true;
              const sGlow = 0.6+Math.sin(gameTime*8+nx*10)*0.4;
              const core = Math.abs(ny-0.1)/bladeW;
              r=100+155*(1-core)*sGlow; g=150+105*(1-core)*sGlow; b=255*sGlow;
            }
          }

          // Shield shimmer (hexagonal pattern)
          const shieldDist = nx*nx*1.5 + ny*ny;
          if (shieldDist > 0.15 && shieldDist < 0.55 && e.hitFlash <= 0) {
            const hex = Math.sin(nx*25)*Math.cos(ny*25+gameTime*3);
            if (hex > 0.7) {
              const shimmer = (hex-0.7)*3.3 * (0.3+Math.sin(gameTime*5)*0.15);
              r+=shimmer*30; g+=shimmer*15; b+=shimmer*60;
            }
          }

          if (draw) { r+=rim*60; g+=rim*30; b+=rim*120; }
        }

      } else { // hunter
        // Massive armored body
        let widthAtY;
        if (ny < -0.35) widthAtY = 0.15+Math.max(0,ny+0.45)*1.5; // Tiny head
        else if (ny < -0.1) widthAtY = 0.3; // Neck collar
        else if (ny < 0.35) widthAtY = 0.65; // Massive torso
        else widthAtY = 0.6-Math.max(0,ny-0.35)*0.7; // Legs

        // Shield arm extends left
        const shieldArm = (nx < -0.3 && ny > -0.2 && ny < 0.35) ? Math.abs(nx+0.3) < 0.35 : false;

        if ((Math.abs(nx) < widthAtY && ny > -0.5 && ny < 0.85) || shieldArm) {
          draw = true;
          const effW = shieldArm ? 0.65 : widthAtY;
          const nz = Math.sqrt(Math.max(0, 1-(nx/effW)**2-ny*ny*0.2));
          const shade = Math.max(0.2, nz*0.5+0.5);
          const spec = Math.pow(Math.max(0,nz*0.7-nx*0.3),6)*0.3;
          const rim = Math.pow(1-Math.abs(nz),3)*0.5;

          // Shield arm
          if (shieldArm) {
            r=50*shade+spec*60; g=80*shade+spec*80; b=170*shade+spec*200;
            if (Math.abs(Math.sin(ny*12+nx*8))<0.05) { r*=0.6; g*=0.6; b*=0.6; }
            // Shield edge glow
            if (nx < -0.55) { r+=40; g+=60; b+=100; }
          }
          // Head
          else if (ny < -0.25) {
            r=30*shade; g=50*shade; b=120*shade;
            // Eyes
            if (ny>-0.4&&ny<-0.32&&(Math.abs(nx-0.04)<0.02||Math.abs(nx+0.04)<0.02)) {
              r=100;g=200;b=255;
            }
          }
          // Collar
          else if (ny < -0.1) {
            r=45*shade+spec*50; g=70*shade+spec*80; b=160*shade+spec*180;
            // Massive collar plates
            if (Math.abs(Math.sin(nx*12))<0.06) { r+=30; g+=40; b+=70; }
          }
          // Torso - exposed worm colony on back
          else if (ny < 0.35) {
            if (nx > 0.15 && ny > 0.0 && ny < 0.3) {
              // Orange worm colony
              const wormN = fbm(nx*40+gameTime,ny*40,2);
              const wGlow = 0.6+Math.sin(gameTime*3+wormN*10)*0.4;
              r=220*shade*wGlow; g=140*shade*wGlow; b=30*shade;
              // Writhing worm detail
              r+=Math.sin(ny*50+gameTime*4)*30; g+=Math.sin(nx*60+gameTime*3)*20;
            } else {
              r=40*shade+spec*40; g=65*shade+spec*60; b=150*shade+spec*160;
              if (Math.abs(Math.sin(ny*10+nx*8))<0.04) { r*=0.6; g*=0.6; b*=0.6; }
            }
          }
          // Legs
          else {
            if (Math.abs(nx) < 0.06) draw = false;
            else { r=35*shade; g=55*shade; b=130*shade; }
          }

          // Fuel rod cannon (right side)
          if (ny > -0.15 && ny < 0.2 && nx > 0.3 && nx < 0.75) {
            draw = true;
            r=40*shade; g=50*shade; b=45*shade;
            // Cannon barrel
            if (ny > 0.0 && ny < 0.08 && nx > 0.55) {
              r=20; g=30; b=25;
              // Muzzle glow
              if (nx > 0.68) {
                const cGlow = 0.5+Math.sin(gameTime*4)*0.5;
                r=50*cGlow; g=255*cGlow; b=100*cGlow;
              }
            }
          }

          if (draw) { r+=rim*40; g+=rim*60; b+=rim*120; }
        }
      }

      // Hit flash: white-hot with electric crackle
      if (draw && e.hitFlash > 0) {
        const flash = e.hitFlash / 0.15;
        const crackle = hash(sx*7+sy*11+(gameTime*100|0), sy*3+sx*5);
        if (crackle < 80) {
          r = r*(1-flash)+255*flash;
          g = g*(1-flash)+255*flash;
          b = b*(1-flash)+255*flash;
        } else {
          r = r*(1-flash*0.7)+255*flash*0.7;
          g = g*(1-flash*0.5)+220*flash*0.5;
          b = b*(1-flash*0.3)+180*flash*0.3;
        }
      }

      // Health bar
      if (ny < -0.88 && ny > -0.95 && Math.abs(nx) < 0.4) {
        draw = true;
        const hpPct = e.health / e.maxHealth;
        if ((nx+0.4)/0.8 < hpPct) {
          r=hpPct>0.5?50:255; g=hpPct>0.5?255:hpPct>0.25?200:50; b=50;
        } else { r=20; g=8; b=8; }
      }

      if (draw) {
        r=r*lr; g=g*lg; b=b*lb;
        r=r*(1-fogF)+8*fogF; g=g*(1-fogF)+5*fogF; b=b*(1-fogF)+18*fogF;
        const pi=(py*RENDER_W+px)*4;
        buf[pi]=Math.max(0,Math.min(255,r|0)); buf[pi+1]=Math.max(0,Math.min(255,g|0));
        buf[pi+2]=Math.max(0,Math.min(255,b|0));
      }
    }
  }
}

function renderAlly(a, screenX, dist, halfH, pitchOff, lr, lg, lb, fogF) {
  const sprH = Math.floor((RENDER_H / dist) * a.size);
  if (sprH < 2) return;
  const sprW = Math.floor(sprH * 0.7);
  const startX = Math.floor(screenX - sprW/2);
  const startY = Math.floor(halfH - sprH/2 + pitchOff);
  const walkBob = a.state !== 'hold' ? Math.sin(gameTime*7+a.x*5)*0.02 : 0;
  for (let sy = 0; sy < sprH; sy++) {
    for (let sx = 0; sx < sprW; sx++) {
      const px = startX + sx, py = startY + sy;
      if (px < 0 || px >= RENDER_W || py < 0 || py >= RENDER_H) continue;
      if (dist > zBuffer[px]) continue;
      const nx = (sx / sprW - 0.5) * 2;
      const ny = (sy / sprH - 0.5) * 2 + walkBob;
      let r = 0, g = 0, b = 0, draw = false;
      // Helmet
      if (ny < -0.25 && ny > -0.55 && Math.abs(nx) < 0.3) {
        draw = true;
        const nz = Math.sqrt(Math.max(0, 1 - (nx/0.3)**2 - ((ny+0.4)/0.2)**2));
        const shade = Math.max(0.3, nz*0.5+0.5);
        r = 60*shade; g = 80*shade; b = 50*shade;
        if (ny > -0.45 && ny < -0.32 && Math.abs(nx) < 0.18) {
          const vGlow = 0.7+Math.sin(gameTime*2)*0.3;
          r = 40*vGlow; g = 180*vGlow; b = 220*vGlow;
        }
      }
      // Neck
      else if (ny < -0.15 && ny > -0.25 && Math.abs(nx) < 0.12) {
        draw = true; r = 140; g = 110; b = 80;
      }
      // Torso
      else if (ny >= -0.15 && ny < 0.3) {
        const widthAtY = 0.45 + ny*0.1;
        if (Math.abs(nx) < widthAtY) {
          draw = true;
          const nz = Math.sqrt(Math.max(0, 1 - (nx/widthAtY)**2));
          const shade = Math.max(0.25, nz*0.5+0.5);
          r = 55*shade; g = 75*shade; b = 45*shade;
          if (Math.abs(nx) < 0.2 && ny > -0.05 && ny < 0.15) { r = 70*shade; g = 90*shade; b = 55*shade; }
          if (Math.abs(Math.sin(ny*18))<0.07) { r*=0.7; g*=0.7; b*=0.7; }
        }
      }
      // Legs
      else if (ny >= 0.3 && ny < 0.85) {
        const legW = 0.15;
        if ((nx > 0.04 && nx < 0.04+legW) || (nx < -0.04 && nx > -0.04-legW)) {
          draw = true; r = 50; g = 65; b = 40;
        }
      }
      // Weapon
      if (ny > -0.1 && ny < 0.15 && nx > 0.2 && nx < 0.55) {
        draw = true; r = 50; g = 55; b = 50;
        if (nx > 0.48 && a.fireTimer > a.fireRate * 0.7) { r = 200; g = 255; b = 100; }
      }
      // Name tag
      if (ny < -0.65 && ny > -0.72 && Math.abs(nx) < 0.35) {
        draw = true; r = 40; g = 200; b = 80;
      }
      // Health bar
      if (ny < -0.58 && ny > -0.64 && Math.abs(nx) < 0.35) {
        draw = true;
        const hpPct = a.health / a.maxHealth;
        if ((nx + 0.35) / 0.7 < hpPct) { r = hpPct > 0.5 ? 50 : 255; g = hpPct > 0.5 ? 255 : 50; b = 50; }
        else { r = 20; g = 8; b = 8; }
      }
      if (draw) {
        r=r*lr; g=g*lg; b=b*lb;
        r=r*(1-fogF)+8*fogF; g=g*(1-fogF)+5*fogF; b=b*(1-fogF)+18*fogF;
        const pi=(py*RENDER_W+px)*4;
        buf[pi]=Math.max(0,Math.min(255,r|0)); buf[pi+1]=Math.max(0,Math.min(255,g|0));
        buf[pi+2]=Math.max(0,Math.min(255,b|0));
      }
    }
  }
}

function renderPickup(p,screenX,dist,halfH,pitchOff,lr,lg,lb,fogF){
  const sprH=Math.floor((RENDER_H/dist)*0.35); if(sprH<2) return;
  const startX=Math.floor(screenX-sprH/2);
  const startY=Math.floor(halfH-sprH/2+pitchOff+Math.sin(gameTime*3)*sprH*0.1);
  let baseR,baseG,baseB;
  if(p.type==='health'){baseR=40;baseG=220;baseB=60;}else if(p.type==='ammo'){baseR=230;baseG=190;baseB=40;}else{baseR=40;baseG=140;baseB=240;}
  const glow=0.7+Math.sin(gameTime*4)*0.3;
  for(let sy=0;sy<sprH;sy++){for(let sx=0;sx<sprH;sx++){
    const px=startX+sx,py=startY+sy;
    if(px<0||px>=RENDER_W||py<0||py>=RENDER_H) continue;if(dist>zBuffer[px]) continue;
    const nx2=(sx/sprH-0.5)*2,ny2=(sy/sprH-0.5)*2;
    if(Math.abs(nx2)+Math.abs(ny2)<0.75){
      const nz2=Math.sqrt(Math.max(0,1-nx2*nx2-ny2*ny2));
      const shade=nz2*0.6+0.4,spec=Math.pow(nz2,6)*0.5;
      let r=baseR*shade*glow+spec*200,g=baseG*shade*glow+spec*200,b=baseB*shade*glow+spec*200;
      if(p.type==='health'&&((Math.abs(nx2)<0.12&&Math.abs(ny2)<0.35)||(Math.abs(ny2)<0.12&&Math.abs(nx2)<0.35))){r=255;g=255;b=255;}
      r=r*lr*(1-fogF)+8*fogF;g=g*lg*(1-fogF)+5*fogF;b=b*lb*(1-fogF)+18*fogF;
      const pi=(py*RENDER_W+px)*4;
      buf[pi]=Math.max(0,Math.min(255,r|0));buf[pi+1]=Math.max(0,Math.min(255,g|0));buf[pi+2]=Math.max(0,Math.min(255,b|0));
    }
  }}
}

function renderGrenade(g,screenX,dist,halfH,pitchOff,fogF){
  const sprH=Math.floor((RENDER_H/dist)*0.15); if(sprH<2) return;
  const zOff = g.z * RENDER_H / dist;
  const startX=Math.floor(screenX-sprH/2),startY=Math.floor(halfH-sprH/2+pitchOff-zOff);
  for(let sy=0;sy<sprH;sy++){for(let sx=0;sx<sprH;sx++){
    const px=startX+sx,py=startY+sy;
    if(px<0||px>=RENDER_W||py<0||py>=RENDER_H) continue;if(dist>zBuffer[px]) continue;
    const nx2=(sx/sprH-0.5)*2,ny2=(sy/sprH-0.5)*2,d2=nx2*nx2+ny2*ny2;
    if(d2<0.9){const glow2=Math.max(0,1-d2);
      const flash=g.life<0.5?Math.abs(Math.sin(g.life*20)):0;
      let r=60+flash*200,gc=120*glow2+flash*100,b=20;
      r=r*(1-fogF)+8*fogF;gc=gc*(1-fogF)+5*fogF;b=b*(1-fogF)+18*fogF;
      const pi=(py*RENDER_W+px)*4;
      buf[pi]=Math.min(255,r|0);buf[pi+1]=Math.min(255,gc|0);buf[pi+2]=Math.min(255,b|0);
    }
  }}
}

function renderProjectile(p,screenX,dist,halfH,pitchOff,fogF){
  const sprH=Math.floor((RENDER_H/dist)*0.2); if(sprH<1) return;
  const startX=Math.floor(screenX-sprH/2),startY=Math.floor(halfH-sprH/2+pitchOff);
  const col=p.color||[0,180,255];
  for(let sy=0;sy<sprH;sy++){for(let sx=0;sx<sprH;sx++){
    const px=startX+sx,py=startY+sy;
    if(px<0||px>=RENDER_W||py<0||py>=RENDER_H) continue;if(dist>zBuffer[px]) continue;
    const nx2=(sx/sprH-0.5)*2,ny2=(sy/sprH-0.5)*2,d2=nx2*nx2+ny2*ny2;
    if(d2<0.9){const glow2=Math.max(0,1-d2),core=glow2>0.5?1:0;
      let r=col[0]*glow2+200*core,g=col[1]*glow2+200*core,b=col[2]*glow2+255*core;
      r=r*(1-fogF)+8*fogF;g=g*(1-fogF)+5*fogF;b=b*(1-fogF)+18*fogF;
      const pi=(py*RENDER_W+px)*4;
      buf[pi]=Math.min(255,buf[pi]+(r|0));buf[pi+1]=Math.min(255,buf[pi+1]+(g|0));buf[pi+2]=Math.min(255,buf[pi+2]+(b|0));
    }
  }}
}

// ============================================================================
//  PARTICLES
// ============================================================================
function spawnParticle(x,y,z,vx,vy,vz,color,life,size){if(particles.length>600) return;particles.push({x,y,z,vx,vy,vz,color,life,maxLife:life,size:size||1});}

function updateLiveGrenades(dt) {
  for (let i = liveGrenades.length - 1; i >= 0; i--) {
    const g = liveGrenades[i];
    g.x += g.vx * dt; g.y += g.vy * dt; g.z += g.vz * dt;
    g.vz -= 8 * dt; // gravity
    // Bounce off floor
    if (g.z <= 0) { g.z = 0; g.vz = Math.abs(g.vz) * 0.3; g.vx *= 0.6; g.vy *= 0.6; g.bounced = true; }
    // Bounce off walls
    if (getMap(Math.floor(g.x), Math.floor(g.y)) > 0) { g.vx *= -0.5; g.vy *= -0.5; g.x += g.vx * dt * 2; g.y += g.vy * dt * 2; }
    // Trail particles
    spawnParticle(g.x, g.y, g.z, (Math.random()-0.5)*0.5, (Math.random()-0.5)*0.5, Math.random()*0.5, [255, 200, 50], 0.2, 1);
    g.life -= dt;
    if (g.life <= 0) {
      // EXPLODE!
      playSound('explosion');
      // Damage all enemies in blast radius
      const blastRadius = 4.0;
      for (const e of enemies) {
        if (!e.alive) continue;
        const edx = e.x - g.x, edy = e.y - g.y, eDist = Math.sqrt(edx*edx + edy*edy);
        if (eDist < blastRadius) {
          const dmg = 80 * (1 - eDist / blastRadius);
          e.health -= dmg; e.hitFlash = 0.3; e.state = 'chase';
          player.damageDealt += dmg;
          if (e.health <= 0) { e.alive = false; player.kills++; playSound('enemy_die'); }
        }
      }
      // Self-damage if too close
      const pdx = player.x - g.x, pdy = player.y - g.y, pDist = Math.sqrt(pdx*pdx + pdy*pdy);
      if (pDist < blastRadius) {
        const selfDmg = 30 * (1 - pDist / blastRadius);
        let dmg = selfDmg;
        if (player.shield > 0) { const sd = Math.min(player.shield, dmg); player.shield -= sd; dmg -= sd; }
        player.health -= dmg; player.damageFlash = 0.8; player.shieldRegenTimer = 0;
      }
      // Big explosion particles
      for (let j = 0; j < 40; j++) {
        const angle = Math.random() * Math.PI * 2, spd = 2 + Math.random() * 6;
        const col = Math.random() > 0.5 ? [255, 150 + Math.random()*100|0, 0] : [255, 255, 100 + Math.random()*100|0];
        spawnParticle(g.x, g.y, g.z + 0.2, Math.cos(angle)*spd, Math.sin(angle)*spd, 2 + Math.random()*4, col, 0.5 + Math.random()*0.5, 3);
      }
      // Smoke ring
      for (let j = 0; j < 20; j++) {
        const angle = Math.random() * Math.PI * 2, spd = 1 + Math.random() * 3;
        spawnParticle(g.x, g.y, g.z, Math.cos(angle)*spd, Math.sin(angle)*spd, Math.random()*2, [80, 80, 80], 0.8 + Math.random()*0.4, 4);
      }
      liveGrenades.splice(i, 1);
    }
  }
}

function updateParticles(dt){for(let i=particles.length-1;i>=0;i--){const p=particles[i];p.x+=p.vx*dt;p.y+=p.vy*dt;p.z+=p.vz*dt;p.vz-=4*dt;p.life-=dt;if(p.life<=0)particles.splice(i,1);}}

function renderParticles(){
  const halfH=RENDER_H/2,pitchOff=player.pitch*250,fov=Math.PI/3;
  for(const p of particles){
    const dx=p.x-player.x,dy=p.y-player.y,dist=Math.sqrt(dx*dx+dy*dy);
    if(dist<0.1||dist>18) continue;
    let relAngle=Math.atan2(dy,dx)-player.angle;
    while(relAngle>Math.PI)relAngle-=2*Math.PI;while(relAngle<-Math.PI)relAngle+=2*Math.PI;
    if(Math.abs(relAngle)>fov*0.6) continue;
    const sx2=Math.floor(RENDER_W/2+(relAngle/fov)*RENDER_W);
    const sy2=Math.floor(halfH-(p.z*RENDER_H/dist)+pitchOff);
    const alpha=p.life/p.maxLife;
    const pSize=Math.max(1,Math.floor(p.size*RENDER_H/dist*0.05));
    for(let py2=-pSize;py2<=pSize;py2++){for(let px2=-pSize;px2<=pSize;px2++){
      const ppx=sx2+px2,ppy=sy2+py2;
      if(ppx<0||ppx>=RENDER_W||ppy<0||ppy>=RENDER_H) continue;
      if(dist>zBuffer[ppx]&&pSize<3) continue;
      const d=Math.sqrt(px2*px2+py2*py2)/(pSize+1);if(d>1) continue;
      const fade=(1-d)*alpha;const pi=(ppy*RENDER_W+ppx)*4;
      buf[pi]=Math.min(255,buf[pi]+(p.color[0]*fade|0));
      buf[pi+1]=Math.min(255,buf[pi+1]+(p.color[1]*fade|0));
      buf[pi+2]=Math.min(255,buf[pi+2]+(p.color[2]*fade|0));
    }}
  }
}

// ============================================================================
//  GAME LOGIC
// ============================================================================
function canMove(x,y,r){r=r||0.25;for(let dx2=-1;dx2<=1;dx2+=2) for(let dy2=-1;dy2<=1;dy2+=2) if(getMap(Math.floor(x+dx2*r),Math.floor(y+dy2*r))>0) return false;return true;}

function lineOfSight(x1,y1,x2,y2){const dx=x2-x1,dy=y2-y1,dist=Math.sqrt(dx*dx+dy*dy),steps=Math.ceil(dist*4);for(let i=0;i<=steps;i++){const t=i/steps;if(getMap(Math.floor(x1+dx*t),Math.floor(y1+dy*t))>0) return false;}return true;}

function updatePlayer(dt) {
  // === LOOK / AIM ===
  if (handControlActive) {
    smoothLookX = smoothLookX*0.4 + gestureInput.lookX*0.6;
    smoothLookY = smoothLookY*0.4 + gestureInput.lookY*0.6;
    let lookInputX = smoothLookX * 3.0;
    let lookInputY = smoothLookY * 2.5;
    // Head turn adds to look direction
    if (gestureInput.headDetected && headCalibrated) {
      smoothHeadTurnX = smoothHeadTurnX*0.5 + gestureInput.headTurnX*0.5;
      smoothHeadTurnY = smoothHeadTurnY*0.5 + gestureInput.headTurnY*0.5;
      lookInputX += smoothHeadTurnX * 1.8;
      lookInputY += smoothHeadTurnY * 1.2;
    }
    player.angle += lookInputX * dt;
    player.pitch = Math.max(-0.5, Math.min(0.5, player.pitch + lookInputY * dt));
  }
  if (!handControlActive || mouseLocked) {
    player.angle += mouseDX * 0.002;
    player.pitch = Math.max(-0.5, Math.min(0.5, player.pitch - mouseDY * 0.002));
    mouseDX = 0; mouseDY = 0;
  }

  // === MOVEMENT ===
  const gSprint = handControlActive && gestureInput.sprint;
  const kSprint = keys['ShiftLeft'] || keys['ShiftRight'];
  const sprint = gSprint || kSprint;
  const speed = (sprint ? player.sprintSpeed : player.moveSpeed) * dt;
  let mx = 0, my = 0, moving = false;

  // Keyboard movement
  if (keys['KeyW']||keys['ArrowUp']) { mx+=Math.cos(player.angle); my+=Math.sin(player.angle); }
  if (keys['KeyS']||keys['ArrowDown']) { mx-=Math.cos(player.angle); my-=Math.sin(player.angle); }
  if (keys['KeyA']||keys['ArrowLeft']) { mx+=Math.cos(player.angle-Math.PI/2); my+=Math.sin(player.angle-Math.PI/2); }
  if (keys['KeyD']||keys['ArrowRight']) { mx-=Math.cos(player.angle-Math.PI/2); my-=Math.sin(player.angle-Math.PI/2); }

  // STOP SIGN = FREEZE ‚Äî skip all gesture movement
  const frozen = handControlActive && gestureInput.stopSign;

  // FACE = PRIMARY MOVEMENT (tilt head forward = walk forward, lean left/right = strafe)
  if (handControlActive && gestureInput.headDetected && headCalibrated && !frozen) {
    // Fluid smoothing ‚Äî high blend factor = responsive, slight smoothing = no jitter
    smoothHeadX = smoothHeadX*0.15 + gestureInput.headX*0.85;
    smoothHeadY = smoothHeadY*0.15 + gestureInput.headY*0.85;
    const headDeadZone = 0.12;
    // Forward/backward: tilt head forward (positive headY) = walk forward
    if (Math.abs(smoothHeadY) > headDeadZone) {
      const raw = smoothHeadY > 0 ? smoothHeadY - headDeadZone : smoothHeadY + headDeadZone;
      // Quadratic ramp for fluid acceleration ‚Äî small tilt = gentle, big tilt = fast
      const sign = raw > 0 ? 1 : -1;
      const fwd = sign * raw * raw * 0.8 + raw * 0.5;
      mx += Math.cos(player.angle) * fwd * 1.4;
      my += Math.sin(player.angle) * fwd * 1.4;
    }
    // Strafe: lean face left/right
    if (Math.abs(smoothHeadX) > headDeadZone) {
      const raw = smoothHeadX > 0 ? smoothHeadX - headDeadZone : smoothHeadX + headDeadZone;
      const sign = raw > 0 ? 1 : -1;
      const strafe = sign * raw * raw * 0.6 + raw * 0.4;
      mx += Math.cos(player.angle-Math.PI/2) * strafe * 1.2;
      my += Math.sin(player.angle-Math.PI/2) * strafe * 1.2;
    }
  }

  // AIM ASSIST ‚Äî gently pull aim toward nearest visible enemy
  if (handControlActive) {
    let closestAngleDiff = 0.35, closestEnemy = null;
    for (const e of enemies) {
      if (!e.alive) continue;
      const edx = e.x - player.x, edy = e.y - player.y, eDist = Math.sqrt(edx*edx + edy*edy);
      if (eDist > 15 || eDist < 0.5) continue;
      if (!lineOfSight(player.x, player.y, e.x, e.y)) continue;
      let diff = Math.atan2(edy, edx) - player.angle;
      while(diff > Math.PI) diff -= 2*Math.PI; while(diff < -Math.PI) diff += 2*Math.PI;
      if (Math.abs(diff) < closestAngleDiff) { closestAngleDiff = Math.abs(diff); closestEnemy = { dx: edx, dy: edy, diff }; }
    }
    if (closestEnemy) {
      player.angle += closestEnemy.diff * 2.0 * dt;
    }
  }

  if (mx !== 0 || my !== 0) {
    const len = Math.sqrt(mx*mx+my*my);
    mx=mx/len*speed; my=my/len*speed; moving=true;
    if (canMove(player.x+mx, player.y, 0.25)) player.x += mx;
    if (canMove(player.x, player.y+my, 0.25)) player.y += my;
    lightCacheValid = false;
  }

  if (moving) { player.bobPhase+=dt*(sprint?14:10); player.bobAmount=Math.min(1,player.bobAmount+dt*5); }
  else { player.bobAmount=Math.max(0, player.bobAmount-dt*5); }

  // === WEAPON SWITCH ===
  if (keys['Digit1']) player.weapon = 0;
  if (keys['Digit2']) player.weapon = 1;
  if (keys['Digit3']) player.weapon = 2;
  if (handControlActive && gestureInput.weapon >= 0) player.weapon = gestureInput.weapon;

  // === RELOAD ===
  const w = player.weapons[player.weapon];
  const wantReload = keys['KeyR'] || (handControlActive && gestureInput.reload);
  if (wantReload && !player.reloading && w.ammo<w.maxAmmo && w.reserve>0) {
    player.reloading=true; player.reloadTimer=1.5; playSound('reload');
  }
  if (player.reloading) {
    player.reloadTimer -= dt;
    if (player.reloadTimer <= 0) {
      const need=w.maxAmmo-w.ammo, avail=Math.min(need,w.reserve);
      w.ammo+=avail; w.reserve-=avail; player.reloading=false;
    }
  }

  // === FIRE ===
  player.fireTimer -= dt;
  player.muzzleFlash = Math.max(0, player.muzzleFlash-dt*12);
  player.weaponKickback = Math.max(0, player.weaponKickback-dt*8);
  player.damageFlash = Math.max(0, player.damageFlash-dt*4);

  const gFire = handControlActive && gestureInput.fire;
  const wantFire = mouseDown || gFire;
  // For non-auto weapons with gesture, require pinch release between shots
  const fireEdge = w.auto ? wantFire : (wantFire && (!gFire || !lastGestureFire));
  lastGestureFire = gFire;

  if (fireEdge && player.fireTimer<=0 && !player.reloading) {
    if (w.ammo > 0) {
      w.ammo--; player.fireTimer=w.fireRate; player.muzzleFlash=1; player.weaponKickback=1;
      playSound(w.sound);
      const pellets = w.pellets||1;
      for (let p=0; p<pellets; p++) {
        const spread=(Math.random()-0.5)*w.spread+(Math.random()-0.5)*w.spread*0.5;
        const shootAngle=player.angle+spread;
        const ray=castRay(player.x,player.y,shootAngle);
        for(let i=0;i<3;i++){const pa=shootAngle+(Math.random()-0.5)*0.6;
          spawnParticle(player.x+Math.cos(shootAngle)*0.5,player.y+Math.sin(shootAngle)*0.5,0.3+Math.random()*0.2,Math.cos(pa)*4+Math.random(),Math.sin(pa)*4+Math.random(),Math.random()*2.5,[255,220,100+Math.random()*80|0],0.15+Math.random()*0.1,2);}
        let hitEnemy=null, hitDist=ray.dist;
        for(const e of enemies){if(!e.alive) continue;
          const ex=e.x-player.x,ey=e.y-player.y,eDist=Math.sqrt(ex*ex+ey*ey);
          if(eDist>=hitDist) continue;
          let diff=shootAngle-Math.atan2(ey,ex);
          while(diff>Math.PI)diff-=2*Math.PI;while(diff<-Math.PI)diff+=2*Math.PI;
          if(Math.abs(diff)<(e.size/eDist)*0.6){hitDist=eDist;hitEnemy=e;}}
        if(hitEnemy){const dmg=w.damage/pellets;hitEnemy.health-=dmg;hitEnemy.hitFlash=0.15;hitEnemy.state='chase';
          player.damageDealt+=dmg;playSound('hit');
          for(let i=0;i<8;i++){const col=hitEnemy.type==='grunt'?[200,100+Math.random()*50|0,0]:hitEnemy.type==='elite'?[120,40,200+Math.random()*55|0]:[40,80+Math.random()*40|0,220];
            spawnParticle(hitEnemy.x,hitEnemy.y,0.2+Math.random()*0.4,(Math.random()-0.5)*4,(Math.random()-0.5)*4,Math.random()*4,col,0.4+Math.random()*0.3,2);}
          if(hitEnemy.health<=0){hitEnemy.alive=false;player.kills++;playSound('enemy_die');
            for(let i=0;i<25;i++){const col=hitEnemy.type==='grunt'?[200+Math.random()*55|0,100,0]:hitEnemy.type==='elite'?[120,40,200+Math.random()*55|0]:[40,80,200+Math.random()*55|0];
              spawnParticle(hitEnemy.x,hitEnemy.y,0.1+Math.random()*0.6,(Math.random()-0.5)*6,(Math.random()-0.5)*6,Math.random()*6,col,0.6+Math.random()*0.6,3);}}}
        else{const hx=player.x+Math.cos(shootAngle)*ray.dist,hy=player.y+Math.sin(shootAngle)*ray.dist;
          for(let i=0;i<6;i++)spawnParticle(hx,hy,0.2+Math.random()*0.6,(Math.random()-0.5)*3,(Math.random()-0.5)*3,Math.random()*3,[255,200+Math.random()*55|0,50+Math.random()*100|0],0.2+Math.random()*0.2,1.5);}
      }
      if(!w.auto && !gFire) mouseDown=false;
    } else { playSound('no_ammo'); player.fireTimer=0.3; }
  }

  // === GRENADES ===
  player.grenadeTimer = Math.max(0, player.grenadeTimer - dt);
  throwCooldown = Math.max(0, throwCooldown - dt);
  if (gestureInput.throwGrenade) {
    gestureInput.throwGrenade = false;
    if (player.grenades > 0 && player.grenadeTimer <= 0) {
      player.grenades--;
      player.grenadeTimer = 1.0;
      playSound('grenade_throw');
      lastVoiceCommand = 'üß® GRENADE'; voiceCommandTimer = 1.5;
      liveGrenades.push({
        x: player.x + Math.cos(player.angle) * 0.5,
        y: player.y + Math.sin(player.angle) * 0.5,
        z: 0.4,
        vx: Math.cos(player.angle) * 6,
        vy: Math.sin(player.angle) * 6,
        vz: 3.0,
        life: 2.0,
        bounced: false
      });
    }
  }

  // === DOORS ===
  const wantInteract = keys['KeyE'] || (handControlActive && gestureInput.interact);
  if (wantInteract) tryOpenDoor();
  autoOpenDoors();
  updateDoors(dt);

  // === SHIELD REGEN ===
  if(player.shield<player.maxShield){player.shieldRegenTimer+=dt;
    if(player.shieldRegenTimer>=player.shieldRegenDelay){player.shield=Math.min(player.maxShield,player.shield+player.shieldRegenRate*dt);player.shieldFlash=0.3;
      player.shieldRegenSoundCd-=dt;if(player.shieldRegenSoundCd<=0){playSound('shield_regen');player.shieldRegenSoundCd=1.5;}}}
  else player.shieldRegenSoundCd=0;
  player.shieldFlash=Math.max(0,player.shieldFlash-dt*3);

  // === PICKUPS ===
  for(const p of pickups){if(!p.alive) continue;const dx=p.x-player.x,dy=p.y-player.y,d2=dx*dx+dy*dy;
    const range=wantInteract?2.0:0.6;
    if(d2<range){
      if(p.type==='health'&&player.health<player.maxHealth){player.health=Math.min(player.maxHealth,player.health+p.amount);p.alive=false;playSound('pickup');}
      else if(p.type==='ammo'){player.weapons[p.weapon].reserve+=player.weapons[p.weapon].maxAmmo*2;p.alive=false;playSound('pickup');}
      else if(p.type==='shield'){player.shield=Math.min(player.maxShield,player.shield+p.amount);p.alive=false;playSound('pickup');}}}

  // Win check
  const pmx=Math.floor(player.x),pmy=Math.floor(player.y);
  for(let ox=-1;ox<=1;ox++) for(let oy=-1;oy<=1;oy++){
    if(getRawMap(pmx+ox,pmy+oy)===6){const ddx=(pmx+ox+0.5)-player.x,ddy=(pmy+oy+0.5)-player.y;
      if(ddx*ddx+ddy*ddy<1.5){winGame();return;}}}
}

function updateEnemies(dt){
  for(const e of enemies){if(!e.alive) continue;
    e.hitFlash=Math.max(0,e.hitFlash-dt);
    e.animTimer+=dt;if(e.animTimer>0.25){e.animFrame=(e.animFrame+1)%4;e.animTimer=0;}
    const dx=player.x-e.x,dy=player.y-e.y,dist=Math.sqrt(dx*dx+dy*dy);
    const canSee=dist<e.range&&lineOfSight(e.x,e.y,player.x,player.y);
    if(canSee){e.state='chase';e.lastSeen={x:player.x,y:player.y};e.alertTimer=5;
      for(const o of enemies){if(!o.alive||o===e) continue;if(Math.sqrt((o.x-e.x)**2+(o.y-e.y)**2)<8&&o.state==='idle'){o.state='chase';o.lastSeen={x:player.x,y:player.y};o.alertTimer=3;}}}
    if(e.state==='chase'){
      e.alertTimer-=dt;if(e.alertTimer<=0&&!canSee){e.state='idle';continue;}
      if(dist>2){const mx2=dx/dist*e.speed*dt,my2=dy/dist*e.speed*dt;
        if(canMove(e.x+mx2,e.y+my2,0.3)){e.x+=mx2;e.y+=my2;}
        else if(canMove(e.x+mx2,e.y,0.3))e.x+=mx2;
        else if(canMove(e.x,e.y+my2,0.3))e.y+=my2;
        else{const px=-dy/dist*e.speed*dt,py=dx/dist*e.speed*dt;if(canMove(e.x+px,e.y+py,0.3)){e.x+=px;e.y+=py;}}}
      if(canSee&&dist<e.range){e.fireTimer-=dt;if(e.fireTimer<=0){e.fireTimer=e.fireRate+Math.random()*0.5;
        const angle=Math.atan2(dy,dx)+(Math.random()-0.5)*0.12;
        const col=e.type==='grunt'?[255,120,20]:[120,60,255];
        projectiles.push({x:e.x,y:e.y,z:0.3,vx:Math.cos(angle)*6,vy:Math.sin(angle)*6,damage:e.damage,color:col,life:3,owner:'enemy'});
        playSound(e.shootSound);
        for(let i=0;i<3;i++)spawnParticle(e.x,e.y,0.3,Math.cos(angle)*2+Math.random(),Math.sin(angle)*2+Math.random(),Math.random(),col,0.15,2);}}
    }else{e.x+=Math.sin(gameTime+e.x*10)*0.3*dt;e.y+=Math.cos(gameTime+e.y*10)*0.3*dt;
      if(!canMove(e.x,e.y,0.3)){e.x-=Math.sin(gameTime+e.x*10)*0.3*dt;e.y-=Math.cos(gameTime+e.y*10)*0.3*dt;}}
  }
}

function updateProjectiles(dt){
  for(let i=projectiles.length-1;i>=0;i--){const p=projectiles[i];
    p.x+=p.vx*dt;p.y+=p.vy*dt;p.life-=dt;
    if(getMap(Math.floor(p.x),Math.floor(p.y))>0||p.life<=0){
      for(let j=0;j<5;j++)spawnParticle(p.x,p.y,0.3,(Math.random()-0.5)*3,(Math.random()-0.5)*3,Math.random()*2,p.color,0.3,2);
      projectiles.splice(i,1);continue;}
    if(p.owner==='enemy'){const dx=p.x-player.x,dy=p.y-player.y;
      if(dx*dx+dy*dy<0.4){let dmg=p.damage;
        if(player.shield>0){const sd=Math.min(player.shield,dmg);player.shield-=sd;dmg-=sd;if(player.shield<=20)playSound('shield_low');}
        player.health-=dmg;player.damageTaken+=p.damage;player.shieldRegenTimer=0;player.damageFlash=1;playSound('hit');
        for(let j=0;j<5;j++)spawnParticle(player.x,player.y,0.5,(Math.random()-0.5)*3,(Math.random()-0.5)*3,Math.random()*2,[255,50,50],0.3,2);
        projectiles.splice(i,1);if(player.health<=0)playerDeath();continue;}}
    if(p.owner==='ally'){for(const e of enemies){if(!e.alive) continue;const adx=p.x-e.x,ady=p.y-e.y;
      if(adx*adx+ady*ady<0.4){e.health-=p.damage;e.hitFlash=0.15;e.state='chase';playSound('hit');
        for(let j=0;j<5;j++)spawnParticle(e.x,e.y,0.3,(Math.random()-0.5)*3,(Math.random()-0.5)*3,Math.random()*2,[80,255,80],0.3,2);
        if(e.health<=0){e.alive=false;player.kills++;playSound('enemy_die');
          for(let j=0;j<15;j++){const col=e.type==='grunt'?[200+Math.random()*55|0,100,0]:e.type==='elite'?[120,40,200+Math.random()*55|0]:[40,80,200+Math.random()*55|0];
            spawnParticle(e.x,e.y,0.1+Math.random()*0.6,(Math.random()-0.5)*6,(Math.random()-0.5)*6,Math.random()*6,col,0.6+Math.random()*0.6,3);}}
        projectiles.splice(i,1);break;}}}
    spawnParticle(p.x,p.y,0.3,(Math.random()-0.5)*0.3,(Math.random()-0.5)*0.3,0,p.color,0.12,1);
  }
}

// ============================================================================
//  HUD
// ============================================================================
function renderHUD(){
  const w=player.weapons[player.weapon];

  // Shield bar
  const shieldPct=player.shield/player.maxShield;
  const sW=280,sH=13,sX=(RENDER_W-sW)/2,sY=14;
  ctx.fillStyle='rgba(0,10,30,0.6)'; roundRect(ctx,sX-2,sY-2,sW+4,sH+4,4); ctx.fill();
  ctx.strokeStyle='rgba(0,120,255,0.4)'; ctx.lineWidth=1; roundRect(ctx,sX-2,sY-2,sW+4,sH+4,4); ctx.stroke();
  if(shieldPct>0){const grd=ctx.createLinearGradient(sX,0,sX+sW*shieldPct,0);
    if(shieldPct>0.5){grd.addColorStop(0,'#0066cc');grd.addColorStop(1,'#00aaff');}
    else if(shieldPct>0.25){grd.addColorStop(0,'#cc8800');grd.addColorStop(1,'#ffbb00');}
    else{grd.addColorStop(0,'#cc2200');grd.addColorStop(1,'#ff4400');}
    ctx.fillStyle=grd;roundRect(ctx,sX,sY,sW*shieldPct,sH,3);ctx.fill();}
  if(player.shieldFlash>0){ctx.fillStyle=`rgba(0,150,255,${player.shieldFlash*0.3})`;roundRect(ctx,sX-4,sY-4,sW+8,sH+8,6);ctx.fill();}
  ctx.fillStyle='#8be';ctx.font='bold 10px "Segoe UI",sans-serif';ctx.textAlign='center';ctx.fillText('SHIELD',RENDER_W/2,sY-3);

  // Health
  const hPct=player.health/player.maxHealth, hX=20, hY=RENDER_H-40, hW=160, hH=11;
  ctx.fillStyle='rgba(0,10,20,0.6)';roundRect(ctx,hX-2,hY-2,hW+4,hH+4,3);ctx.fill();
  if(hPct>0){const hg=ctx.createLinearGradient(hX,0,hX+hW*hPct,0);
    if(hPct>0.5){hg.addColorStop(0,'#006600');hg.addColorStop(1,'#00cc00');}
    else if(hPct>0.25){hg.addColorStop(0,'#886600');hg.addColorStop(1,'#ccaa00');}
    else{hg.addColorStop(0,'#880000');hg.addColorStop(1,'#ff2200');}
    ctx.fillStyle=hg;roundRect(ctx,hX,hY,hW*hPct,hH,2);ctx.fill();}
  ctx.fillStyle='#ccc';ctx.font='bold 12px "Segoe UI",sans-serif';ctx.textAlign='left';ctx.fillText('HP '+Math.ceil(player.health),hX,hY-5);

  // Ammo
  ctx.fillStyle='rgba(0,10,20,0.6)';roundRect(ctx,RENDER_W-200,RENDER_H-58,190,48,4);ctx.fill();
  ctx.strokeStyle='rgba(100,200,255,0.2)';ctx.lineWidth=1;roundRect(ctx,RENDER_W-200,RENDER_H-58,190,48,4);ctx.stroke();
  ctx.fillStyle='#fff';ctx.font='bold 30px "Segoe UI",sans-serif';ctx.textAlign='right';ctx.fillText(w.ammo,RENDER_W-100,RENDER_H-22);
  ctx.fillStyle='#89a';ctx.font='18px "Segoe UI",sans-serif';ctx.fillText('/ '+w.reserve,RENDER_W-20,RENDER_H-22);
  ctx.fillStyle='#6ad';ctx.font='10px "Segoe UI",sans-serif';ctx.fillText(w.name,RENDER_W-20,RENDER_H-42);

  // Reload bar
  if(player.reloading){const rPct=1-player.reloadTimer/1.5;
    ctx.fillStyle='rgba(0,20,40,0.7)';roundRect(ctx,RENDER_W/2-70,RENDER_H-85,140,18,4);ctx.fill();
    ctx.fillStyle='#4af';roundRect(ctx,RENDER_W/2-68,RENDER_H-83,136*rPct,14,3);ctx.fill();
    ctx.fillStyle='#adf';ctx.font='bold 10px "Segoe UI",sans-serif';ctx.textAlign='center';ctx.fillText('RELOADING',RENDER_W/2,RENDER_H-92);}

  // Crosshair
  const cx2=RENDER_W/2,cy2=RENDER_H/2,cSp=5+player.weaponKickback*7;
  ctx.strokeStyle=player.muzzleFlash>0.3?'rgba(255,200,100,0.9)':'rgba(100,200,255,0.7)';ctx.lineWidth=1.5;
  ctx.beginPath();ctx.moveTo(cx2-cSp-6,cy2);ctx.lineTo(cx2-cSp,cy2);ctx.moveTo(cx2+cSp,cy2);ctx.lineTo(cx2+cSp+6,cy2);
  ctx.moveTo(cx2,cy2-cSp-6);ctx.lineTo(cx2,cy2-cSp);ctx.moveTo(cx2,cy2+cSp);ctx.lineTo(cx2,cy2+cSp+6);ctx.stroke();
  ctx.fillStyle='rgba(255,255,255,0.5)';ctx.fillRect(cx2-0.5,cy2-0.5,1,1);

  renderRadar();

  // Enemy count
  const alive=enemies.filter(e=>e.alive).length;
  ctx.fillStyle='rgba(0,10,20,0.5)';roundRect(ctx,14,8,120,18,3);ctx.fill();
  ctx.fillStyle=alive>0?'#f84':'#4f8';ctx.font='bold 11px "Segoe UI",sans-serif';ctx.textAlign='left';
  ctx.fillText('HOSTILES: '+alive,20,22);

  // Grenade count
  const grenX=RENDER_W-200, grenY=RENDER_H-110;
  ctx.fillStyle='rgba(0,10,20,0.6)';roundRect(ctx,grenX,grenY,80,22,4);ctx.fill();
  ctx.strokeStyle='rgba(200,160,0,0.3)';ctx.lineWidth=1;roundRect(ctx,grenX,grenY,80,22,4);ctx.stroke();
  ctx.fillStyle=player.grenades>0?'#fd0':'#555';ctx.font='bold 12px "Segoe UI",sans-serif';ctx.textAlign='left';
  ctx.fillText('\u{1F4A3} '+player.grenades+'/'+player.maxGrenades,grenX+8,grenY+16);

  // ‚îÄ‚îÄ INPUT STATUS BAR ‚îÄ‚îÄ
  if(handControlActive){
    const gy=RENDER_H-62;
    const barW=200, barX=RENDER_W/2-barW/2;
    ctx.fillStyle='rgba(0,15,10,0.6)';roundRect(ctx,barX,gy,barW,20,4);ctx.fill();
    ctx.strokeStyle='rgba(0,180,80,0.25)';ctx.lineWidth=1;roundRect(ctx,barX,gy,barW,20,4);ctx.stroke();
    const hCount=(gestureInput.leftDetected?1:0)+(gestureInput.rightDetected?1:0);
    const headOk=gestureInput.headDetected&&headCalibrated;
    // Hands indicator
    ctx.fillStyle=hCount>0?'#0f8':'#555';ctx.font='bold 9px monospace';ctx.textAlign='left';
    ctx.fillText('\u270B '+hCount+'/2',barX+8,gy+14);
    // Head indicator
    ctx.fillStyle=headOk?'#fd0':gestureInput.headDetected?'#a80':'#555';
    ctx.fillText('\u{1F9D1} '+(headOk?'HEAD':'---'),barX+58,gy+14);
    // Mic indicator
    ctx.fillStyle=voiceActive?'#4af':'#555';
    const micAlpha=voiceActive?(0.7+Math.sin(gameTime*4)*0.3):0.4;
    ctx.globalAlpha=micAlpha;
    ctx.fillText('\u{1F3A4} '+(voiceActive?'MIC':'OFF'),barX+120,gy+14);
    ctx.globalAlpha=1;
    // Stop/frozen indicator
    if(gestureInput.stopSign){
      ctx.fillStyle='#f44';ctx.font='bold 10px monospace';
      ctx.textAlign='center';
      const freezePulse = 0.6+Math.sin(gameTime*6)*0.4;
      ctx.globalAlpha=freezePulse;
      ctx.fillText('\u{1F6D1} FROZEN',RENDER_W/2,gy-6);
      ctx.globalAlpha=1;
    }
  }

  // ‚îÄ‚îÄ VOICE COMMAND CALLOUT ‚îÄ‚îÄ
  if(voiceCommandTimer>0){
    const cmdAlpha=Math.min(1,voiceCommandTimer);
    const cmdW=240, cmdH=32, cmdX=RENDER_W/2-cmdW/2, cmdY=38;
    // Glowing background
    const cmdGrd=ctx.createLinearGradient(cmdX,cmdY,cmdX+cmdW,cmdY);
    cmdGrd.addColorStop(0,`rgba(0,40,80,${cmdAlpha*0.6})`);
    cmdGrd.addColorStop(0.5,`rgba(0,60,120,${cmdAlpha*0.8})`);
    cmdGrd.addColorStop(1,`rgba(0,40,80,${cmdAlpha*0.6})`);
    ctx.fillStyle=cmdGrd;roundRect(ctx,cmdX,cmdY,cmdW,cmdH,6);ctx.fill();
    ctx.strokeStyle=`rgba(80,200,255,${cmdAlpha*0.6})`;ctx.lineWidth=1.5;roundRect(ctx,cmdX,cmdY,cmdW,cmdH,6);ctx.stroke();
    // Glow line at top
    const topGrd=ctx.createLinearGradient(cmdX+20,cmdY,cmdX+cmdW-20,cmdY);
    topGrd.addColorStop(0,'rgba(80,200,255,0)');topGrd.addColorStop(0.5,`rgba(80,200,255,${cmdAlpha*0.5})`);topGrd.addColorStop(1,'rgba(80,200,255,0)');
    ctx.strokeStyle=topGrd;ctx.lineWidth=1;ctx.beginPath();ctx.moveTo(cmdX+20,cmdY);ctx.lineTo(cmdX+cmdW-20,cmdY);ctx.stroke();
    // Icon + text
    ctx.fillStyle=`rgba(140,230,255,${cmdAlpha})`;ctx.font='bold 14px "Segoe UI",sans-serif';ctx.textAlign='center';
    ctx.fillText('\u{1F3A4}  '+lastVoiceCommand,RENDER_W/2,cmdY+22);
  }

  // ‚îÄ‚îÄ SQUAD STATUS PANEL ‚îÄ‚îÄ
  const sqW=160, sqH=24, sqX=RENDER_W-sqW-10, sqY=6;
  const sqGrd=ctx.createLinearGradient(sqX,sqY,sqX+sqW,sqY);
  sqGrd.addColorStop(0,'rgba(0,30,15,0.5)');sqGrd.addColorStop(1,'rgba(0,15,8,0.6)');
  ctx.fillStyle=sqGrd;roundRect(ctx,sqX,sqY,sqW,sqH,4);ctx.fill();
  ctx.strokeStyle='rgba(0,200,100,0.25)';ctx.lineWidth=1;roundRect(ctx,sqX,sqY,sqW,sqH,4);ctx.stroke();
  // Squad command icons
  const cmdIcons={follow:'\u{1F6B6}',attack:'\u2694\uFE0F',retreat:'\u{1F6A8}',cover:'\u{1F6E1}\uFE0F',hold:'\u270B',medic:'\u2695\uFE0F',spread:'\u{1F4A8}'};
  const cmdIcon=cmdIcons[squadCommand]||'\u{1F6B6}';
  ctx.fillStyle=squadCommandTimer>0?'#6f8':'#4d7';ctx.font='bold 11px "Segoe UI",sans-serif';ctx.textAlign='right';
  ctx.fillText(cmdIcon+' SQUAD: '+squadCommand.toUpperCase(),RENDER_W-16,sqY+17);
  // Flash on new command
  if(squadCommandTimer>2){
    ctx.strokeStyle=`rgba(0,255,100,${(squadCommandTimer-2)*0.6})`;ctx.lineWidth=2;
    roundRect(ctx,sqX-2,sqY-2,sqW+4,sqH+4,5);ctx.stroke();
  }

  // ‚îÄ‚îÄ ALLY HEALTH PANEL ‚îÄ‚îÄ
  const allyPanelX=12, allyPanelY0=RENDER_H-258;
  // Panel background
  ctx.fillStyle='rgba(0,12,6,0.55)';roundRect(ctx,allyPanelX-2,allyPanelY0-14,108,allies.length*26+20,4);ctx.fill();
  ctx.strokeStyle='rgba(0,140,70,0.2)';ctx.lineWidth=1;roundRect(ctx,allyPanelX-2,allyPanelY0-14,108,allies.length*26+20,4);ctx.stroke();
  ctx.fillStyle='#4a8';ctx.font='bold 8px "Segoe UI",sans-serif';ctx.textAlign='left';
  ctx.fillText('\u{1F6E1}\uFE0F FIRE TEAM',allyPanelX+4,allyPanelY0-4);
  let allyHudY=allyPanelY0+4;
  for(const a of allies){
    const nameCol=a.alive?'#5fb':'#844';
    ctx.fillStyle=nameCol;ctx.font='bold 8px "Segoe UI",sans-serif';ctx.textAlign='left';
    ctx.fillText(a.name,allyPanelX+4,allyHudY+8);
    if(a.alive){
      const hpPct=a.health/a.maxHealth;
      ctx.fillStyle='rgba(0,0,0,0.4)';ctx.fillRect(allyPanelX+4,allyHudY+11,80,4);
      const hpGrd=ctx.createLinearGradient(allyPanelX+4,0,allyPanelX+4+80*hpPct,0);
      if(hpPct>0.5){hpGrd.addColorStop(0,'#060');hpGrd.addColorStop(1,'#0d0');}
      else if(hpPct>0.25){hpGrd.addColorStop(0,'#860');hpGrd.addColorStop(1,'#fd0');}
      else{hpGrd.addColorStop(0,'#800');hpGrd.addColorStop(1,'#f40');}
      ctx.fillStyle=hpGrd;ctx.fillRect(allyPanelX+4,allyHudY+11,80*hpPct,4);
      // State indicator
      ctx.fillStyle='#6a8';ctx.font='6px monospace';ctx.textAlign='right';
      ctx.fillText(a.state.toUpperCase(),allyPanelX+100,allyHudY+8);
    }else{
      ctx.fillStyle='#f44';ctx.font='bold 7px "Segoe UI",sans-serif';
      ctx.fillText('\u2620 KIA',allyPanelX+4,allyHudY+18);
    }
    allyHudY+=26;
  }

  // Damage vignette
  if(player.damageFlash>0){const da=player.damageFlash*0.4;
    const dg=ctx.createRadialGradient(RENDER_W/2,RENDER_H/2,RENDER_H*0.3,RENDER_W/2,RENDER_H/2,RENDER_H*0.7);
    dg.addColorStop(0,'rgba(200,0,0,0)');dg.addColorStop(1,`rgba(200,0,0,${da})`);
    ctx.fillStyle=dg;ctx.fillRect(0,0,RENDER_W,RENDER_H);}

  if(player.shieldFlash>0.1){ctx.strokeStyle=`rgba(0,150,255,${player.shieldFlash*0.2})`;ctx.lineWidth=2;
    const ins=30-player.shieldFlash*20;roundRect(ctx,ins,ins,RENDER_W-ins*2,RENDER_H-ins*2,8);ctx.stroke();}
  if(player.muzzleFlash>0.5){const ma=(player.muzzleFlash-0.5)*0.15;ctx.fillStyle=`rgba(255,220,100,${ma})`;ctx.fillRect(0,RENDER_H*0.5,RENDER_W,RENDER_H*0.5);}
}

function roundRect(c,x,y,w,h,r){c.beginPath();c.moveTo(x+r,y);c.lineTo(x+w-r,y);c.quadraticCurveTo(x+w,y,x+w,y+r);c.lineTo(x+w,y+h-r);c.quadraticCurveTo(x+w,y+h,x+w-r,y+h);c.lineTo(x+r,y+h);c.quadraticCurveTo(x,y+h,x,y+h-r);c.lineTo(x,y+r);c.quadraticCurveTo(x,y,x+r,y);c.closePath();}

function renderRadar(){
  const rS=90,rx=16,ry=RENDER_H-145,rcx=rx+rS/2,rcy=ry+rS/2;
  ctx.fillStyle='rgba(0,15,5,0.65)';ctx.beginPath();ctx.arc(rcx,rcy,rS/2+2,0,Math.PI*2);ctx.fill();
  ctx.strokeStyle='rgba(0,180,80,0.4)';ctx.lineWidth=1;ctx.beginPath();ctx.arc(rcx,rcy,rS/2+2,0,Math.PI*2);ctx.stroke();
  ctx.strokeStyle='rgba(0,80,30,0.3)';ctx.beginPath();ctx.arc(rcx,rcy,rS/4,0,Math.PI*2);ctx.stroke();
  ctx.beginPath();ctx.moveTo(rcx-rS/2,rcy);ctx.lineTo(rcx+rS/2,rcy);ctx.moveTo(rcx,rcy-rS/2);ctx.lineTo(rcx,rcy+rS/2);ctx.stroke();
  const sw=gameTime*2;ctx.strokeStyle='rgba(0,255,80,0.15)';ctx.lineWidth=1;ctx.beginPath();ctx.moveTo(rcx,rcy);
  ctx.lineTo(rcx+Math.cos(sw)*rS/2,rcy+Math.sin(sw)*rS/2);ctx.stroke();
  ctx.strokeStyle='#0f8';ctx.lineWidth=1.5;ctx.beginPath();ctx.moveTo(rcx,rcy);
  ctx.lineTo(rcx+Math.cos(player.angle)*8,rcy+Math.sin(player.angle)*8);ctx.stroke();
  ctx.fillStyle='#0f0';ctx.beginPath();ctx.arc(rcx,rcy,2,0,Math.PI*2);ctx.fill();
  for(const e of enemies){if(!e.alive) continue;const dx=e.x-player.x,dy=e.y-player.y;
    if(Math.sqrt(dx*dx+dy*dy)>15) continue;const ex=rcx+dx*2.5,ey=rcy+dy*2.5;
    if(Math.sqrt((ex-rcx)**2+(ey-rcy)**2)>rS/2-2) continue;
    ctx.fillStyle=e.state==='chase'?'#f33':'#f80';ctx.beginPath();ctx.arc(ex,ey,1.5,0,Math.PI*2);ctx.fill();}
  for(const p of pickups){if(!p.alive) continue;const dx=p.x-player.x,dy=p.y-player.y;
    if(Math.sqrt(dx*dx+dy*dy)>15) continue;const px2=rcx+dx*2.5,py2=rcy+dy*2.5;
    if(Math.sqrt((px2-rcx)**2+(py2-rcy)**2)>rS/2-2) continue;
    ctx.fillStyle='#0ff';ctx.fillRect(px2-1,py2-1,2,2);}
  for(const a of allies){if(!a.alive) continue;const dx=a.x-player.x,dy=a.y-player.y;
    if(Math.sqrt(dx*dx+dy*dy)>15) continue;const ax2=rcx+dx*2.5,ay2=rcy+dy*2.5;
    if(Math.sqrt((ax2-rcx)**2+(ay2-rcy)**2)>rS/2-2) continue;
    ctx.fillStyle='#4f8';ctx.beginPath();ctx.arc(ax2,ay2,2,0,Math.PI*2);ctx.fill();}
}

// ============================================================================
//  WEAPON RENDERING
// ============================================================================
function renderWeapon(){
  const bob=Math.sin(player.bobPhase)*10*player.bobAmount;
  const bobY=Math.abs(Math.sin(player.bobPhase))*6*player.bobAmount;
  const kick=player.weaponKickback*14;
  let bX=RENDER_W/2-60+bob,bY=RENDER_H-135+bobY+kick;
  if(player.reloading){const t=player.reloadTimer/1.5;bY+=Math.sin(t*Math.PI)*55;bX+=Math.sin(t*Math.PI*2)*12;}
  ctx.save();
  if(player.weapon===0) drawAR(bX,bY);
  else if(player.weapon===1) drawPistol(bX,bY);
  else drawShotgun(bX,bY);
  if(player.muzzleFlash>0.4){
    const fi=player.muzzleFlash-0.4;
    const fx=bX+(player.weapon===2?120:player.weapon===1?90:105);
    const fy=bY+(player.weapon===2?30:player.weapon===1?35:27);
    const fSz=14+Math.random()*12;
    const grd=ctx.createRadialGradient(fx,fy,0,fx,fy,fSz*2);
    grd.addColorStop(0,`rgba(255,255,230,${fi})`);grd.addColorStop(0.3,`rgba(255,200,50,${fi*0.7})`);
    grd.addColorStop(0.6,`rgba(255,100,0,${fi*0.3})`);grd.addColorStop(1,'rgba(255,50,0,0)');
    ctx.fillStyle=grd;ctx.fillRect(fx-fSz*2,fy-fSz*2,fSz*4,fSz*4);
    ctx.fillStyle=`rgba(255,255,255,${fi})`;ctx.beginPath();ctx.arc(fx,fy,fSz*0.4,0,Math.PI*2);ctx.fill();
  }
  ctx.restore();
}

function drawBevel(x,y,w,h,lt,dk){ctx.strokeStyle=lt;ctx.lineWidth=1;ctx.beginPath();ctx.moveTo(x,y+h);ctx.lineTo(x,y);ctx.lineTo(x+w,y);ctx.stroke();ctx.strokeStyle=dk;ctx.beginPath();ctx.moveTo(x+w,y);ctx.lineTo(x+w,y+h);ctx.lineTo(x,y+h);ctx.stroke();}

function drawAR(x,y){
  ctx.fillStyle='#3a3a3a';ctx.fillRect(x-12,y+20,35,24);drawBevel(x-12,y+20,35,24,'#4a4a4a','#2a2a2a');
  const bg=ctx.createLinearGradient(x,y+12,x,y+44);bg.addColorStop(0,'#6a6a6a');bg.addColorStop(0.5,'#555');bg.addColorStop(1,'#444');
  ctx.fillStyle=bg;ctx.fillRect(x+18,y+16,80,20);
  ctx.fillStyle='#5e5e5e';ctx.fillRect(x+20,y+12,60,7);drawBevel(x+20,y+12,60,7,'#6e6e6e','#4e4e4e');
  const br=ctx.createLinearGradient(x+92,y+20,x+92,y+34);br.addColorStop(0,'#5a5a5a');br.addColorStop(1,'#3a3a3a');
  ctx.fillStyle=br;ctx.fillRect(x+92,y+20,28,12);ctx.fillStyle='#111';ctx.fillRect(x+117,y+23,5,6);
  ctx.fillStyle='#333';ctx.fillRect(x+40,y+36,16,34);drawBevel(x+40,y+36,16,34,'#444','#222');
  ctx.fillStyle='#4a4a4a';ctx.fillRect(x+58,y+36,12,22);
  ctx.fillStyle='#001800';ctx.fillRect(x+25,y+20,28,12);
  ctx.fillStyle='#0f0';ctx.font='bold 10px monospace';ctx.textAlign='center';
  ctx.fillText(String(player.weapons[0].ammo).padStart(2,'0'),x+39,y+30);
}

function drawPistol(x,y){
  x+=12;y+=6;
  const sg=ctx.createLinearGradient(x+12,y+22,x+12,y+40);sg.addColorStop(0,'#5a5a5a');sg.addColorStop(1,'#3a3a3a');
  ctx.fillStyle=sg;ctx.fillRect(x+12,y+24,62,16);drawBevel(x+12,y+24,62,16,'#6a6a6a','#2a2a2a');
  ctx.fillStyle='#4a4a4a';ctx.fillRect(x+72,y+28,20,9);ctx.fillStyle='#111';ctx.fillRect(x+89,y+30,4,5);
  ctx.fillStyle='#444';ctx.fillRect(x+28,y+20,35,7);drawBevel(x+28,y+20,35,7,'#555','#333');
  ctx.fillStyle='#225';ctx.fillRect(x+35,y+18,9,5);ctx.fillStyle='rgba(100,150,255,0.3)';ctx.fillRect(x+36,y+19,7,3);
  ctx.fillStyle='#2a2a2a';ctx.beginPath();ctx.moveTo(x+35,y+40);ctx.lineTo(x+44,y+40);ctx.lineTo(x+48,y+75);ctx.lineTo(x+30,y+75);ctx.closePath();ctx.fill();
  ctx.strokeStyle='#3a3a3a';ctx.lineWidth=2;ctx.beginPath();ctx.arc(x+40,y+44,7,0,Math.PI);ctx.stroke();
  ctx.fillStyle='#333';ctx.fillRect(x+39,y+42,2,6);
}

function drawShotgun(x,y){
  x-=6;
  ctx.fillStyle='#5a3520';ctx.fillRect(x-18,y+18,35,20);
  ctx.strokeStyle='#4a2510';ctx.lineWidth=0.5;
  for(let gy=y+20;gy<y+36;gy+=2){ctx.beginPath();ctx.moveTo(x-15,gy);ctx.bezierCurveTo(x-6,gy+Math.sin(gy),x+6,gy-Math.sin(gy),x+15,gy);ctx.stroke();}
  const bg=ctx.createLinearGradient(x+12,y+16,x+12,y+42);bg.addColorStop(0,'#5e5e5e');bg.addColorStop(1,'#3e3e3e');
  ctx.fillStyle=bg;ctx.fillRect(x+14,y+16,75,20);drawBevel(x+14,y+16,75,20,'#6e6e6e','#2e2e2e');
  ctx.fillStyle='#4a4a4a';ctx.fillRect(x+86,y+18,40,12);ctx.fillStyle='#3a3a3a';ctx.fillRect(x+86,y+30,40,6);
  ctx.fillStyle='#111';ctx.beginPath();ctx.arc(x+124,y+24,6,0,Math.PI*2);ctx.fill();
  ctx.fillStyle='#222';ctx.beginPath();ctx.arc(x+124,y+24,4,0,Math.PI*2);ctx.fill();
  ctx.fillStyle='#4a2a15';ctx.fillRect(x+38,y+36,16,32);drawBevel(x+38,y+36,16,32,'#5a3a25','#3a1a05');
}

// ============================================================================
//  POST-PROCESSING
// ============================================================================
function applyPostFX(){
  // Vignette
  const grd=ctx.createRadialGradient(RENDER_W/2,RENDER_H/2,RENDER_H*0.35,RENDER_W/2,RENDER_H/2,RENDER_H*0.75);
  grd.addColorStop(0,'rgba(0,0,0,0)');grd.addColorStop(1,'rgba(0,0,0,0.3)');
  ctx.fillStyle=grd;ctx.fillRect(0,0,RENDER_W,RENDER_H);
  // Subtle blue shadow tint
  ctx.globalCompositeOperation='multiply';
  const tint=ctx.createRadialGradient(RENDER_W/2,RENDER_H/2,0,RENDER_W/2,RENDER_H/2,RENDER_H);
  tint.addColorStop(0,'rgb(255,252,248)');tint.addColorStop(1,'rgb(200,210,235)');
  ctx.fillStyle=tint;ctx.fillRect(0,0,RENDER_W,RENDER_H);
  ctx.globalCompositeOperation='source-over';
}

// ============================================================================
//  GAME STATE
// ============================================================================
function playerDeath(){gameRunning=false;if(mouseLocked)document.exitPointerLock();document.getElementById('death-screen').style.display='flex';}
function winGame(){gameRunning=false;if(mouseLocked)document.exitPointerLock();
  document.getElementById('win-stats').textContent=`Kills: ${player.kills} | Damage Dealt: ${Math.floor(player.damageDealt)} | Damage Taken: ${Math.floor(player.damageTaken)} | Time: ${Math.floor(gameTime)}s`;
  document.getElementById('win-screen').style.display='flex';}
function restartGame(){document.getElementById('death-screen').style.display='none';document.getElementById('win-screen').style.display='none';initGame();if(!handControlActive)canvas.requestPointerLock();}

function initGame(){
  player.x=2.5;player.y=2.5;player.angle=0;player.pitch=0;
  player.health=100;player.shield=100;player.shieldRegenTimer=0;
  player.weapon=0;player.fireTimer=0;player.muzzleFlash=0;
  player.bobPhase=0;player.bobAmount=0;player.reloading=false;player.reloadTimer=0;
  player.kills=0;player.damageDealt=0;player.damageTaken=0;
  player.weaponKickback=0;player.damageFlash=0;player.shieldFlash=0;player.shieldRegenSoundCd=0;
  player.weapons[0].ammo=32;player.weapons[0].reserve=256;
  player.weapons[1].ammo=12;player.weapons[1].reserve=120;
  player.weapons[2].ammo=8;player.weapons[2].reserve=40;
  player.grenades=4;player.grenadeTimer=0;
  projectiles=[];particles=[];liveGrenades=[];gameTime=0;lightCacheValid=false;
  lastGestureFire=false;smoothLookX=0;smoothLookY=0;smoothMoveX=0;smoothMoveY=0;
  prevRightWristY=null;throwCooldown=0;
  allies=[];voiceCommandTimer=0;squadCommand='follow';squadCommandTimer=0;
  tutorialStep=0;tutorialTimer=0;tutorialArrowTarget=null;
  if(currentLevel==='tutorial') {
    loadTutorialMap();
  } else {
    // Restore original main map
    for (let i = 0; i < MAP_W * MAP_H; i++) mapData[i] = mainMapData[i];
    player.x=2.5;player.y=2.5;player.angle=0;
  }
  initDoors();spawnEnemies();spawnPickups();spawnAllies();gameRunning=true;
}

// ============================================================================
//  TUTORIAL LEVEL
// ============================================================================
const tutorialMapData = [
  1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
  1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,
  1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,
  1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,
  1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,
  1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,
  1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,
  1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,
  1,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,
  1,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,
  1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,
  1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,
  1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,3,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,
  1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,
  1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,
  1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,
  1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,
  1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,1,
  1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,1,
  1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,
  1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,
  1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,
  1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,
  1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,
  1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,
  1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,
  1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,
  1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,
  1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,
  1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,6,0,1,
  1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,
  1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
];

const TUTORIAL_STEPS = [
  { msg: 'üëã WELCOME SPARTAN! Turn your head left and right to look around', done: () => Math.abs(player.angle) > 0.4, time: 0 },
  { msg: 'üèÉ TILT your head forward to walk! Lean back to go backwards', done: () => { const d=Math.sqrt((player.x-2.5)**2+(player.y-2.5)**2); return d > 1.5; }, time: 0 },
  { msg: 'üëç Nice! Now walk to the yellow marker ‚Äî tilt your head that way!', target: {x:10.5,y:10.5}, done: () => Math.sqrt((player.x-10.5)**2+(player.y-10.5)**2) < 2.0, time: 0 },
  { msg: 'üî´ PINCH your right hand to SHOOT! Take out the enemy!', done: () => player.kills > 0, time: 0 },
  { msg: 'üö™ Walk to the small building and through the DOOR!', target: {x:16.5,y:15.5}, done: () => { const d=Math.sqrt((player.x-16.5)**2+(player.y-16.5)**2); return d < 1.5; }, time: 0 },
  { msg: 'üèÅ GREAT JOB! Now find the green EXIT in the far corner!', target: {x:28.5,y:29.5}, done: () => false, time: 0 },
];

function loadTutorialMap() {
  // Copy tutorial map into mapData
  for (let i = 0; i < MAP_W * MAP_H; i++) mapData[i] = tutorialMapData[i];
  player.x = 4.5; player.y = 4.5; player.angle = 0.7;
}

function spawnTutorialEnemies() {
  enemies = [];
  // Scattered easy grunts in the open arena
  enemies.push(createEnemy('grunt', 12.5, 8.5));
  enemies.push(createEnemy('grunt', 20.5, 12.5));
  enemies.push(createEnemy('grunt', 8.5, 18.5));
  enemies.push(createEnemy('grunt', 25.5, 22.5));
  // Super easy ‚Äî low health, slow fire, low damage
  for (const e of enemies) { e.health = 10; e.maxHealth = 10; e.damage = 1; e.fireRate = 4.0; e.speed = 1.0; }
}

function spawnTutorialPickups() {
  pickups = [];
  // Generous pickups scattered around the open field
  pickups.push({type:'health',x:6.5,y:6.5,amount:50,alive:true});
  pickups.push({type:'health',x:20.5,y:20.5,amount:50,alive:true});
  pickups.push({type:'ammo',x:15.5,y:5.5,weapon:0,alive:true});
  pickups.push({type:'ammo',x:25.5,y:15.5,weapon:0,alive:true});
  pickups.push({type:'shield',x:10.5,y:15.5,amount:50,alive:true});
}

function updateTutorial(dt) {
  if (currentLevel !== 'tutorial') return;
  tutorialTimer += dt;
  const step = TUTORIAL_STEPS[tutorialStep];
  if (!step) return;
  tutorialArrowTarget = step.target || null;
  if (step.done()) {
    tutorialStep++;
    tutorialTimer = 0;
    if (tutorialStep < TUTORIAL_STEPS.length) playSound('pickup');
  }
}

function renderTutorialHUD() {
  if (currentLevel !== 'tutorial') return;
  const step = TUTORIAL_STEPS[tutorialStep];
  if (!step) return;
  // Message box at top center
  const msg = step.msg;
  const boxW = Math.min(RENDER_W - 40, 700), boxH = 50;
  const boxX = (RENDER_W - boxW) / 2, boxY = 70;
  const alpha = Math.min(1, tutorialTimer * 2);
  ctx.fillStyle = `rgba(0,20,40,${0.85*alpha})`;
  roundRect(ctx, boxX, boxY, boxW, boxH, 10); ctx.fill();
  ctx.strokeStyle = `rgba(0,200,255,${0.5*alpha})`; ctx.lineWidth = 2;
  roundRect(ctx, boxX, boxY, boxW, boxH, 10); ctx.stroke();
  ctx.fillStyle = `rgba(200,240,255,${alpha})`;
  ctx.font = 'bold 16px "Segoe UI",sans-serif'; ctx.textAlign = 'center';
  ctx.fillText(msg, RENDER_W/2, boxY + 32);
  // Step counter
  ctx.fillStyle = `rgba(100,180,255,${0.6*alpha})`;
  ctx.font = '11px "Segoe UI",sans-serif';
  ctx.fillText('Step ' + (tutorialStep+1) + '/' + TUTORIAL_STEPS.length, RENDER_W/2, boxY + boxH + 16);

  // Arrow pointing toward target
  if (tutorialArrowTarget) {
    const tdx = tutorialArrowTarget.x - player.x, tdy = tutorialArrowTarget.y - player.y;
    const tDist = Math.sqrt(tdx*tdx + tdy*tdy);
    if (tDist > 1.0) {
      let tAngle = Math.atan2(tdy, tdx) - player.angle;
      while(tAngle > Math.PI) tAngle -= 2*Math.PI; while(tAngle < -Math.PI) tAngle += 2*Math.PI;
      const arrowX = RENDER_W/2 + Math.cos(tAngle) * 80;
      const arrowY = RENDER_H/2 + Math.sin(tAngle) * 60;
      const pulse = 0.7 + Math.sin(gameTime * 4) * 0.3;
      ctx.fillStyle = `rgba(255,220,0,${pulse})`;
      ctx.beginPath();
      ctx.moveTo(arrowX + Math.cos(tAngle)*15, arrowY + Math.sin(tAngle)*15);
      ctx.lineTo(arrowX + Math.cos(tAngle+2.5)*10, arrowY + Math.sin(tAngle+2.5)*10);
      ctx.lineTo(arrowX + Math.cos(tAngle-2.5)*10, arrowY + Math.sin(tAngle-2.5)*10);
      ctx.closePath(); ctx.fill();
    }
  }
}

// ============================================================================
//  MAIN LOOP
// ============================================================================
let lastTime=0;
function gameLoop(timestamp){
  const dt=Math.min(0.05,(timestamp-lastTime)/1000);
  lastTime=timestamp;
  if(gameRunning){
    gameTime+=dt;
    updatePlayer(dt);updateEnemies(dt);updateAllies(dt);updateProjectiles(dt);updateLiveGrenades(dt);updateParticles(dt);updateTutorial(dt);
    renderScene();renderSprites();renderParticles();
    ctx.putImageData(screenBuffer,0,0);
    applyPostFX();renderHUD();renderWeapon();renderTutorialHUD();
  }
  requestAnimationFrame(gameLoop);
}

// ============================================================================
//  START
// ============================================================================
// Populate camera dropdown on page load
enumerateCameras();
document.getElementById('btn-refresh-cams').addEventListener('click', (e)=>{ e.preventDefault(); enumerateCameras(); });

document.getElementById('toggle-help').addEventListener('click', ()=>{
  const el = document.getElementById('how-to-play');
  const btn = document.getElementById('toggle-help');
  if(el.style.display==='block') { el.style.display='none'; btn.textContent='? HOW TO PLAY WITH CAMERA'; }
  else { el.style.display='block'; btn.textContent='HIDE GUIDE'; }
});

document.getElementById('btn-camera').addEventListener('click', async ()=>{
  document.getElementById('cam-status').textContent='Initializing camera & microphone...';
  currentLevel = 'main';
  const ok = await initHandTracking();
  document.getElementById('overlay').style.display='none';
  initAudio(); initGame(); await initVoice();
  if(!ok) canvas.requestPointerLock();
  lastTime=performance.now(); requestAnimationFrame(gameLoop);
});

document.getElementById('btn-camera-tutorial').addEventListener('click', async ()=>{
  document.getElementById('cam-status').textContent='Initializing camera & microphone...';
  currentLevel = 'tutorial';
  const ok = await initHandTracking();
  document.getElementById('overlay').style.display='none';
  initAudio(); initGame(); await initVoice();
  if(!ok) canvas.requestPointerLock();
  lastTime=performance.now(); requestAnimationFrame(gameLoop);
});

document.getElementById('btn-keyboard').addEventListener('click', async ()=>{
  document.getElementById('overlay').style.display='none';
  document.getElementById('instr-camera').style.display='none';
  currentLevel = 'main';
  initAudio(); initGame(); await initVoice(); canvas.requestPointerLock();
  lastTime=performance.now(); requestAnimationFrame(gameLoop);
});

// Show appropriate instructions on hover
document.getElementById('btn-preview-cam').addEventListener('click', ()=>{ startOverlayPreview(); });

document.getElementById('btn-camera').addEventListener('mouseenter',()=>{
  document.getElementById('instr-camera').style.display='block';
  document.getElementById('instr-keyboard').style.display='none';
  document.getElementById('cam-select-row').style.display='flex';
});
document.getElementById('btn-camera-tutorial').addEventListener('mouseenter',()=>{
  document.getElementById('instr-camera').style.display='block';
  document.getElementById('instr-keyboard').style.display='none';
  document.getElementById('cam-select-row').style.display='flex';
});
document.getElementById('btn-keyboard').addEventListener('mouseenter',()=>{
  document.getElementById('instr-camera').style.display='none';
  document.getElementById('instr-keyboard').style.display='block';
  document.getElementById('cam-select-row').style.display='none';
});
</script>
</body>
</html>
